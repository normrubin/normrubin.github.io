<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="matinraayai">

<title>Final Project- Lowering AMDGPU LLVM Intrinsics In Instrumentation Functions – EECE7398 Fall 2024</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../blogs/michael/09-20-2024-HW1-MichaelMaurer.html" rel="next">
<link href="../../blogs/matin/2024-11-01-HW5.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c098ae24f13dbac994136fcd8cf45278.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Final Project- Lowering AMDGPU LLVM Intrinsics In Instrumentation Functions – EECE7398 Fall 2024">
<meta property="og:description" content="Homepage EECS7398 - Special Topic: Compilers, Fall 2024.">
<meta property="og:site_name" content="EECE7398 Fall 2024">
</head>

<body class="nav-sidebar docked fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../weekly.html">EECS 7398</a></li><li class="breadcrumb-item">Blogs</li><li class="breadcrumb-item"><a href="../../blogs/matin/2024-09-20-HW1.html">Matin</a></li><li class="breadcrumb-item"><a href="../../blogs/matin/2024-12-12-Final-Project.html">Final Project- Lowering AMDGPU LLVM Intrinsics In Instrumentation Functions</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">EECE7398 Fall 2024</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true">
 <span class="menu-text">EECS 7398</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../weekly.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Weekly Schedule</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Class_Overview/What_to_do.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">How to submit assignments</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Blogs</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">Aymane</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/aymane/final_project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">final project pdf</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/aymane/mlir-transform-dialect.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project Presentation - The MLIR Transform Dialect</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/aymane/readme.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 1 – Trying Out Bril</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/aymane/readme2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 2 – Implementing DCE and LVN</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/aymane/readme3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 3 – Implementing Liveness Dataflow Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/aymane/readme4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 4 – Implementing Dominance Algorithms</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/aymane/readme5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 5 – Implementing a simple LLVM pass</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Matin</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth3 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/matin/2024-09-20-HW1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/matin/2024-09-28-HW2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 2: Trivial Dead Code Elimination and Local Value Numbering Passes</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/matin/2024-10-11-HW3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 3: Dataflow Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/matin/2024-10-18-HW4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 4: Dominance Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/matin/2024-11-01-HW5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 5</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/matin/2024-12-12-Final-Project.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Final Project- Lowering AMDGPU LLVM Intrinsics In Instrumentation Functions</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false">
 <span class="menu-text">Michael</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/michael/09-20-2024-HW1-MichaelMaurer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">EECE7309 Homework 1 – Trying Out Bril</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/michael/09-27-2024-HW2-MichaelMaurer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">EECE7309 Homework 2 – Local Optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/michael/10-11-2024-HW3-MichaelMaurer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">EECE7309 Homework 3 – Data Flow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/michael/10-18-2024-HW4-MichaelMaurer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">EECE7309 Homework 4 – Dominance</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/michael/11-01-2024-HW5-MichaelMaurer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">EECE7309 Homework 5 – LLVM</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/michael/11-26-2024-EATSS-Review.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Paper Presentation – EATSS</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/michael/12-13-2024-Project-MichaelMaurer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Final Project Report – Register Allocator and minimal RISC-V Backend</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false">
 <span class="menu-text">Oscar</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/oscar/2024-09-20-HW1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">HW1 - Trying Out Bril</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/oscar/2024-09-27-HW2-Kellner.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">HW2 - Minor Local Optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/oscar/2024-10-11-HW3-Kellner.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">HW3 - Data Flow Analysis</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false">
 <span class="menu-text">Qucheng</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Qucheng/2024-09-20-Qucheng-HW1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 1: Exploring Bril</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Qucheng/2024-09-27-Qucheng-HW2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 2: Optimizing with DCE and LVN</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Qucheng/2024-10-11-Qucheng-HW3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 3: Data Flow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Qucheng/2024-10-11-Qucheng-HW4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 4: Dominance</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Qucheng/2024-10-11-Qucheng-HW5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 5: LLVM - Spinning Up</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Qucheng/2024-12-01-Qucheng-Prj.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project: Build non-intrusive Software Infrastructure of a GEMM HWACC using MLIR</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Qucheng/Qucheng-Paper-MLIR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Paper Discussion: SODA-OPT</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false">
 <span class="menu-text">Rohit</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/rohit/2024-09-20-Rohit-HW1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/rohit/2024-09-28-Rohit-HW2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/rohit/2024-10-17-Rohit-HW3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 3</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/rohit/2024-10-18-Rohit-HW4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/rohit/2024-11-02-Rohit-HW5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 5</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/rohit/paper_presentation_GPU_compiler_heuristics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Paper Presentation</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="false">
 <span class="menu-text">Project</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth4 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/rohit/project/Project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Machine Learning-Driven Memory Optimization for C++ Applications: A Python-Based Approach</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="false">
 <span class="menu-text">Samples</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/samples/junk_dir/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">sample blog with an image and a graph</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/samples/junk.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">sample blog</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false">
 <span class="menu-text">Sana</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Sana/09-20-2024-HW1-SanaTaghipourAnvari.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework1 - Sana</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Sana/09-27-2024-HW2-SanaTaghipourAnvari.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework2 - local optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Sana/10-11-2024-HW3-SanaTaghipourAnvari.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework3 - data flow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Sana/10-18-2024-HW4-SanaTaghipourAnvari.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework4 - dominance</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Sana/11-1-2024-HW5-SanaTaghipourAnvari.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework5 - LLVM</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Sana/FinalProjectReport.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Layout Optimization and Loop Transformations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/Sana/PaperPresentation-LLMs-for-Compiler-Optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">LLMs for Code Optimization, A Promising Start or Overhyped Solution?</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="false">
 <span class="menu-text">Sharmila</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-11" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/sharmila/2024-09-20-Sharmila-HW01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Compiler Homework 01 - Trying Out Bril</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/sharmila/2024-09-27-Sharmila-HW02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Compiler Homework 02 - Local Optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/sharmila/2024-10-15-Sharmila-HW03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Compiler Homework 03 - Data Flow Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/sharmila/2024-10-18-Sharmila-HW04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Compiler Homework 04 - Implementing Dominance Utilities</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/sharmila/2024-11-01-Sharmila-HW05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Compiler Homework 05 - LLVM Pass</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/sharmila/paper_presentation_GPU_compiler_heuristics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Paper Presentation</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" role="navigation" aria-expanded="false">
 <span class="menu-text">Project</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-12" class="collapse list-unstyled sidebar-section depth4 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/sharmila/project/Project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Machine Learning-Driven Memory Optimization for C++ Applications: A Python-Based Approach</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" role="navigation" aria-expanded="false">
 <span class="menu-text">Yashaswini</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-13" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/yashaswini/09-20-2024-HW1-YashaswiniMakaram.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework1 - Yashaswini</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/yashaswini/09-27-2024-HW2-YashaswiniMakaram.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework2 - Yashaswini</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/yashaswini/10-11-2024-HW3-YashaswiniMakaram.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework3 - Yashaswini</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/yashaswini/10-18-2024-HW4-YashaswiniMakaram.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework4 - Yashaswini</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/yashaswini/11-1-2024-HW5-YashaswiniMakaram.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework5 - Yashaswini</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/yashaswini/FinalReport.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Final Project - Yashaswini</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blogs/yashaswini/PaperPresentation-ProgaML.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Paper Presentation - Yashaswini</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-14" role="navigation" aria-expanded="false">
 <span class="menu-text">Homework</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-14" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-14" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/1.hw.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 1 trying out bril</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/2_hw.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 2 local optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/3_hw.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 4 data flow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/4_hw.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">homework - dominance</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/5_hw.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 5 ssa</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/6_extra_credit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homework 6 loop optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/dynamic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">homework 7 dynamic compile</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/hw0.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">homework 0</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/hw5_llvm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">hw 5 llvm</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../homework/project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">project</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-15" role="navigation" aria-expanded="false">
 <span class="menu-text">Lectures</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-15" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-15" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/010_compiler_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Compiler Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/01a_performance_measurement.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Performance and Measurement</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/01a1_performance_measurement.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Performance and Measurement part 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/01a2_performance_measurement.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Performance and Measurement part 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/02a_representation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Representation of programs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/02b_bril.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview of Bril</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/03_local.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Local Analysis &amp; Optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/03b_local_value_numbering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">local value numbering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/04_data_flow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Flow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/05_global.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5 Global Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/05b_licm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">classic loop optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/05c_pre.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">_ partial_redundancy elimination</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/06_ssa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Static Single Assignment</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/08_classic_loop_ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">classic loop optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/09_poly.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Polyhedral Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/100_mlir.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10 MLIR</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/110_whole_program.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11 Whole program</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/12_memory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dynamic Memory Management</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/13_dynamic_compilers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dynamic Compilers</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/14_gpu_compilers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">GPU Compilers</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/diverg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">divergent flow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/diverg1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">divergent flow PART TWO</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/junk.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">test</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/llvm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">using llvm</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/mem_consistancy.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">memory consistancy</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/mlir.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Polyhedral Compilation Opportunities in MLIR</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/poly_final.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction To Polyhedral Methods</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/ra-checking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Testing Register allocators</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../lectures/register_allocation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Register Allocation</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://capra.cs.cornell.edu/bril/" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bril Documentation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://github.com/normrubin/bril" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bril github</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://github.com/normrubin/normrubin.github.io" class="sidebar-item-text sidebar-link">
 <span class="menu-text">class github</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../weekly.html">EECS 7398</a></li><li class="breadcrumb-item">Blogs</li><li class="breadcrumb-item"><a href="../../blogs/matin/2024-09-20-HW1.html">Matin</a></li><li class="breadcrumb-item"><a href="../../blogs/matin/2024-12-12-Final-Project.html">Final Project- Lowering AMDGPU LLVM Intrinsics In Instrumentation Functions</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Final Project- Lowering AMDGPU LLVM Intrinsics In Instrumentation Functions</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>matinraayai </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>For the past year or so I’ve been working on a framework to instrument AMD GPU code objects at runtime, similar to <a href="https://github.com/NVlabs/NVBit">NVBit</a> for NVIDIA GPUs and <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/gtpin.html">GTPin</a> for Intel GPUs. My final project is essentially a major feature that I wanted to implement in the framework. I think it will be helpful to briefly go over the framework and how it is designed to better understand my final project and the challenges faced when implementing it. ## Background Instrumentation, in a nutshell, entails the modification of a binary in some shape or form, with the goal of gaining a better understanding of how it works. The motivation behind instrumentation ranges from debugging and profiling (e.g.&nbsp;<a href="https://valgrind.org/">Valgrind</a>, <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Sanatizers</a>), to architectural research (e.g.&nbsp;recording the addresses accessed by a target workload to better design future caches). Instrumentation has been done for quite some time on the CPU side; Some examples include Intel’s <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html">Pin</a>, <a href="https://github.com/dyninst/dyninst">DynInst</a>, and <a href="https://dynamorio.org/">DynamoRio</a>. In recent years, this capability has been extended to NVIDIA GPUs via <a href="https://github.com/NVlabs/NVBit">NVBit</a> and to Intel GPUs via <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/gtpin.html">GTPin</a>. Both these frameworks are capable of “dynamic” instrumentation, which means they don’t require access to the source code and modify the binary directly, just before the code runs. “Static” instrumentation, on the other hand, instruments the binary “offline”, and usually during compile time as part of the compilation process. Generally, dynamic instrumentation is preferred since it doesn’t require the recompilation of the target code from scratch, which is impossible to do for closed-source applications. Another advantage of dynamic frameworks is the ability to switch between instrumented and original versions of the binary (also referred to as “selective instrumentation”), as they have access to both versions. This helps tremendously with reducing the overhead caused by instrumentation, which often times is very significant. Static instrumentation, on the other hand, can generated more efficient instrumented code as they have access to the compilation steps and analysis of the target code otherwise not available to dynamic framworks. They also don’t incur a code-generation penalty compared to dynamic frameworks, as this step happens offline in static frameworks.</p>
<p>So far there hasn’t been a successful attempt at creating a framework for dynamically instrumenting AMD GPU applications; Luthier (the framework that I’ve been working on as part of my PhD research), to the best of my (and my collegeues’) knowledege, will be the first ever dynamic instrumentation framework targeting AMD GPUs. In the next section I go over the challenges I faced when designing Luthier, and then go over how it works and how it interfaces with AMD’s hardware and software stack. Since this is a compiler class I will mostly focus on the compiler aspects of Luthier and I only briefly mention details on interfacing with the rest of the <a href="https://www.amd.com/en/products/software/rocm.html">ROCm</a> stack. I will make these details available in the near future.</p>
<section id="luthier-how-it-was-designed-and-how-it-works" class="level2">
<h2 class="anchored" data-anchor-id="luthier-how-it-was-designed-and-how-it-works">Luthier: How It Was Designed, and How It Works</h2>
<p>The initial design of Luthier was heavily inspired by NVBit. NVBit tools are <code>.so</code> shared objects that are loaded before the CUDA application using the <a href="https://www.baeldung.com/linux/ld_preload-trick-what-is"><code>LD_PRELOAD</code> trick</a>. The tools use <a href="https://docs.nvidia.com/cupti/index.html">CUPTI</a> APIs to get notified when the CUDA application hit certain “events” (e.g.&nbsp;calls <code>cudaMalloc</code>, launches a kernel, etc.) through invoking a “callback” function defined inside the tool. NVBit tools use these callbacks to intercept CUDA kernels before they are launched, and afterwards inspect them using <a href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html"><code>nvdisasm</code></a>. Luthier tools works similiar to NVBit tools: they are shared objects loaded using the <code>LD_PRELOAD</code> environment variable; To be able to intercept and inspect kernels we designed a similar mechanism using <a href="https://github.com/ROCm/rocprofiler-sdk/"><code>rocprofiler-sdk</code></a> to notify tools about key events in the application. We then use the ROCr (HSA) runtime APIs to locate where the kernel has been loaded on the target GPU device, and even the ELF (i.e.&nbsp;code object) this kernel was loaded from.</p>
<p>But this was where we ran into the following issues: 1. <strong>We realized that instrumenting AMDGPU code objects the “NVBit way” is not feasible or at best, very hard to implement</strong>: NVBit instruments GPU applications by replacing the target instruction with a <code>JMP</code> to a trampoline region. The trampoline then spills the application’s register onto the thread’s stack, sets up the arguments to a instrumentation device function call, and the proceeds to call it. After returning, the trampoline will restore the registers, execute the original instruction, and then jumps back to the original kernel. This design is successful because SASS (NVIDIA GPU’s hardware assembly) instructions have a fixed size, meaning that it’s very easy to replace a single instruction with a “long jump” to almost any virtual memory address on the device, all without changing the layout of the code. Not changing the code layout is very important in dynamic instrumentation, as it ensures indirect jumps/calls won’t break. This is not the case on AMD GPUs, as CDNA GPUs have a 4-byte short jump, only covering <span class="math inline">\(2^{18}\)</span> bytes, and an 8-byte long jump. To make matters worse, the long jump requires additional instructions to load the jump target into registers. We can argue that we might be able to make the NVBit trampoline work by allocating fixed-address executable memory using a custom allocator (which NVBit seem to also have), but this goes completely against ROCr’s APIs of asking for executable regions of memory using the <code>hsa_executable_t</code> interfaces, and is very hard to implement and manage. Even then this is only a temporary fix, as the aggregation of trampoline logic for each instruction will quickly go over the range managable by the short jump instruction. <strong>This meant we needed a completely different approach for instrumentation</strong>. 2. <strong>Reusing Dead Registers</strong>: NVBit inserts calls to pre-compiled instrumentation device functions with a set calling convention, which NVBit has no choice but to obey by spilling/restoring a large number of thread registers at all times. Accessing the stack is not cheap on GPUs, hence <strong>we wanted to find a way to adapt the same instrumentation function to each instrumentation point to reuse dead registers</strong> in order to speed up instrumented code. 3. <strong>Allocating And Accessing Scratch (Local) Memory Is Not Trivial on AMD GPUs</strong>: in the NVBit paper, accessing the stack (local memory) of each thread for spilling and restoring registers is mentioned; However, how this access is done without interfering with the application’s local memory is not explained. We assume that NVBit assumes all SASS code adhere to NVIDIA’s calling conventions, which is enforced via their virtual PTX ISA; Hence, it can always have a stack pointer which allows for interleaving the spilled registers with the application’s local memory. AMD GPUs, however, can be programmed directly using hardware assembly, and have multiple calling conventions that don’t enforce presence of a stack pointer register. <strong>We needed to find a way to access the stack for instrumentation without the presnce of a stack pointer</strong>. 4. <strong>Requesting access to scratch might displace the SGPR arguments</strong>: According to the <a href="https://llvm.org/docs/AMDGPUUsage.html">AMDGPU LLVM Docs</a>, when a kernel is launched, a set of wavefront-common values are loaded into SGPRs for use by the kernel. This includes the address of the kernel argument buffer or the address of the queue (i.e.&nbsp;command processor) used to launch the kernel. It also includes resources needed to access local/scratch memory in each thread. These resource must be explicitly requested by the kernel, and <a href="https://llvm.org/docs/AMDGPUUsage.html#amdgpu-amdhsa-sgpr-register-set-up-order-table">this table</a> shows the order these SGPRs are setup. One thing to note is that accessing scratch requires access to the “Private Segment Buffer Descriptor” and/or “Flat Scratch Address” of the queue used to launch the kernel, as well as a “wave offset”, which is the offset from the queue’s scratch address to the current wavefront’s scratch space. This makes accessing scratch in instrumentation functions particularly challenging, especially for applications that don’t require scratch and don’t set it up. Luthier <strong>must take into account these shift in SGPR arguments and must emit code to set it up for the instrumentation stack and then move the SGPR arguments to their original place</strong>. It also have to <strong>store the scratch information somewhere to be able to access it later in the instrumentation routines</strong>.</p>
<p>Luthier addresses each of the afformentioned challenge as follows: 1. Instead of carrying out instrumentation by directly modifying the loaded code on the GPU, Luthier opts to create a “standalone executable”, which contains the original code as well as the instrumentation logic. The standalone executable will use ROCr dynamic loader’s features to link against the “static global variables” already loaded in the original code (e.g.&nbsp;variables annotated with <code>__device__</code> or <code>__managed__</code> in HIP code). This respects the ROCr APIs the most, not requiring any significant changes to the low level runtime. 2. Instead of calling pre-compiled device functions, Luthier embeds the optimized LLVM IR bitcode of the device instrumentation logic in its device code objects at tool compile time. This ensures that the HIP runtime will load the bitcode for free, allowing the Luthier runtime to do more optimizations on the instrumentation logic and adapt it to each instrumentation point. 3. (and 4.) Luthier defines a new concept called the “State Value Array (SVA)”, an array of 64 32-bit values that can be loaded into a single VGPR of a single wavefront (each wavefront has 64 threads). SVA is in charge of storing the instrumentation stack information, which is always allocated on top of what the application requested originally. It also keeps track of other wavefront-specific values. SVA is setup using a “Kernel preamble code”, which reads the SGPR arguments and saves them into the SVA’s VGPR lanes, right before reverting the SGPR arguments back to their original formation before the target kernel starts executing. SVA is stored in the applications’ dead/unused registers. In most recent hardware, the SVA can be either stored in a single A/VGPR, or spilled on a static point of the kernel stack with a single SGPR pointing to it so it can be loaded later using <code>SCRATCH</code> instructions.</p>
<p>Luthier implements these designs by heavily leveraging the LLVM project and its AMDGPU backend, which we explain in more detail below:</p>
<section id="disassembling-lifting-and-inspecting-code-objects" class="level3">
<h3 class="anchored" data-anchor-id="disassembling-lifting-and-inspecting-code-objects">Disassembling, Lifting, and Inspecting Code Objects</h3>
<p>As we mentioned earlier, Luthier instruments code by duplicating the target application’s code so that it can freely inject instrumentation logic inside it. To do this, Luthier takes in a single ELF/executable, and inspects its symbols using LLVM’s object utilities. It then identifies the kernels and device functions inside the ELF and disassembles them into LLVM MC instructions. <a href="https://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html">MC</a> is the machine code/assembler layer of LLVM. It is meant to represent “physical” instructions and registers. While disassembling code, Luthier identifies the branch instructions and identifies their targets if possible for later use.</p>
<p>After disassembly is complete Luthier uses the obtained information from the ELF to “lift” it to LLVM Machine IR (MIR). <a href="https://llvm.org/docs/CodeGenerator.html">MIR</a> is LLVM’s representation used in its target-independent code generator (i.e.&nbsp;backends). It is a superset of LLVM MC, meaning an LLVM MC instruction can also be easily converted to an LLVM MIR instruction by reusing the same enums for opcodes and registers. The reason behind lifting to LLVM MIR is as follows: 1. MIR has very convenient ways for iterating over the code and querying properties regarding the code and the instructions which is otherwise costly to implement ourselves. 2. MIR’s high-level utilities allow for removing/adding things to the ELF otherwise not possible with ELF-modification frameworks e.g.&nbsp;<a href="https://github.com/serge1/ELFIO/tree/main">ELFIO</a>. This makes it easy to modify the kernel specifications and removing symbols that are not used in the target kernel and are unrelated. 3. The compiler machine passes only operate on the MIR representation. Lifting to MIR makes it easier to re-use analysis already available in LLVM’s code generator or add new ones.</p>
<p>LLVM MIR consists of a set of “pseudo” instructions that is equivalent to a set of “physical”, target-specific instructions in MC; For example, <code>S_ADD_U32</code> is a pseudo instruction in MIR which maps to <code>S_ADD_U32_vi</code>, <code>S_ADD_32_gfx12</code>, and so on. The same goes for some registers e.g.&nbsp;<code>TTMP</code> or <code>M0</code>. The primary reason for this indirection is to allow for different encoding/decodings on different targets. Although in theory, one should be able to use both pseudo and target-specific opcodes in the MIR, the AMDGPU backend primarily expects the pseudo variant to be present in the code; Hence during its tool library compilation, Luthier uses LLVM’s <a href="https://llvm.org/docs/TableGen/">TableGen</a> to read over all the opcodes/registers and creates an inverse mapping between target-specific opcode and their pseudo equivalents. Luthier then uses this table to convert the opcode and registers to their pseudo variants during runtime.</p>
<p>Just like <a href="https://github.com/llvm/llvm-project/blob/main/bolt/README.md">LLVM Bolt</a>, Luthier requires the inspected ELFs to have full relocation information. This way, it is able to correctly lift things like reading the address of a symbol:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode asm code-with-copy"><code class="sourceCode fasm"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>s_getpc_b64 s<span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">5</span><span class="op">]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>s_add_u32 s4<span class="op">,</span> s4<span class="op">,</span> func1<span class="fu">@r</span>el32<span class="fu">@</span><span class="er">l</span>o<span class="op">+</span><span class="dv">4</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>s_addc_u32 s5<span class="op">,</span> s5<span class="op">,</span> func1<span class="fu">@r</span>el32<span class="fu">@</span><span class="er">l</span>o<span class="op">+</span><span class="dv">4</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the future, we will have to add analysis logic to at least reduce this restriction; For now, however, it is more than enough for a proof-of-concept. The result of the lifting process it a <code>LiftedRepresentation</code>, which is a mapping between the HSA/ROCr symbols of the ELF and their LLVM equivalent.</p>
</section>
<section id="writing-luthier-tools" class="level3">
<h3 class="anchored" data-anchor-id="writing-luthier-tools">Writing Luthier Tools</h3>
<p>A sample Luthier tool can look like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> luthier<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">/// Kernel instruction counter</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ex">__attribute__((managed))</span> <span class="dt">uint64_t</span> Counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">/// Macro marking the device module (code object) of this tool to</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">/// be a Luthier tool</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>MARK_LUTHIER_DEVICE_MODULE</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>LUTHIER_HOOK_ANNOTATE countInstructionsVector<span class="op">(</span><span class="dt">bool</span> CountWaveFrontLevel<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the exec mask of the wavefront</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> ExecMask <span class="op">=</span> <span class="fu">__builtin_amdgcn_read_exec</span><span class="op">();</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the position of the thread in the current wavefront (1-index)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">uint32_t</span> LaneId <span class="op">=</span> __lane_id<span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the first active thread id inside this wavefront</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> FirstActiveThreadId <span class="op">=</span> __ffsll<span class="op">(</span>ExecMask<span class="op">);</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the number of active threads in this wavefront</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> NumActiveThreads <span class="op">=</span> __popcll<span class="op">(</span>ExecMask<span class="op">);</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Have only the first active thread perform the atomic add</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>FirstActiveThreadId <span class="op">==</span> LaneId<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>CountWaveFrontLevel<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Num threads can be zero when accounting for predicates off</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>NumActiveThreads <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        atomicAdd<span class="op">(&amp;</span>Counter<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>      atomicAdd<span class="op">(&amp;</span>Counter<span class="op">,</span> NumActiveThreads<span class="op">);</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>LUTHIER_EXPORT_HOOK_HANDLE<span class="op">(</span>countInstructionsVector<span class="op">);</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>LUTHIER_HOOK_ANNOTATE countInstructionsScalar<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the exec mask of the wavefront</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> ExecMask <span class="op">=</span> <span class="fu">__builtin_amdgcn_read_exec</span><span class="op">();</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Overwrite the exec mask with one so that only a single thread is active</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>  luthier<span class="op">::</span>writeExec<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Increment the counter by 1</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>  atomicAdd<span class="op">(&amp;</span>Counter<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Restore the exec mask</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>  luthier<span class="op">::</span>writeExec<span class="op">(</span>ExecMask<span class="op">);</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>LUTHIER_EXPORT_HOOK_HANDLE<span class="op">(</span>countInstructionsScalar<span class="op">);</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> llvm<span class="op">::</span>Error instrumentationLoop<span class="op">(</span>InstrumentationTask <span class="op">&amp;</span>IT<span class="op">,</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>                                       LiftedRepresentation <span class="op">&amp;</span>LR<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Create a constant bool indicating the CountWavefrontLevel value</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">*</span>CountWavefrontLevelConstVal <span class="op">=</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>      llvm<span class="op">::</span>ConstantInt<span class="op">::</span>getBool<span class="op">(</span>LR<span class="op">.</span>getContext<span class="op">(),</span> CountWavefrontLevel<span class="op">);</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">int</span> I <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;[</span>_<span class="op">,</span> MF<span class="op">]</span> <span class="op">:</span> LR<span class="op">.</span>functions<span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>MBB <span class="op">:</span> <span class="op">*</span>MF<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>MI <span class="op">:</span> MBB<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>I <span class="op">&gt;=</span> InstrBeginInterval <span class="op">&amp;&amp;</span> I <span class="op">&lt;</span> InstrEndInterval<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>          <span class="dt">bool</span> IsScalar <span class="op">=</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>              llvm<span class="op">::</span>SIInstrInfo<span class="op">::</span>isSOP1<span class="op">(</span>MI<span class="op">)</span> <span class="op">||</span> llvm<span class="op">::</span>SIInstrInfo<span class="op">::</span>isSOP2<span class="op">(</span>MI<span class="op">)</span> <span class="op">||</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>              llvm<span class="op">::</span>SIInstrInfo<span class="op">::</span>isSOPK<span class="op">(</span>MI<span class="op">)</span> <span class="op">||</span> llvm<span class="op">::</span>SIInstrInfo<span class="op">::</span>isSOPC<span class="op">(</span>MI<span class="op">)</span> <span class="op">||</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>              llvm<span class="op">::</span>SIInstrInfo<span class="op">::</span>isSOPP<span class="op">(</span>MI<span class="op">)</span> <span class="op">||</span> llvm<span class="op">::</span>SIInstrInfo<span class="op">::</span>isSMRD<span class="op">(</span>MI<span class="op">);</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>          <span class="dt">bool</span> IsLaneAccess <span class="op">=</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>              MI<span class="op">.</span>getOpcode<span class="op">()</span> <span class="op">==</span> llvm<span class="op">::</span>AMDGPU<span class="op">::</span>V_READFIRSTLANE_B32 <span class="op">||</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>              MI<span class="op">.</span>getOpcode<span class="op">()</span> <span class="op">==</span> llvm<span class="op">::</span>AMDGPU<span class="op">::</span>V_READLANE_B32 <span class="op">||</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>              MI<span class="op">.</span>getOpcode<span class="op">()</span> <span class="op">==</span> llvm<span class="op">::</span>AMDGPU<span class="op">::</span>V_WRITELANE_B32<span class="op">;</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>IsScalar <span class="op">||</span> IsLaneAccess<span class="op">)</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>            LUTHIER_RETURN_ON_ERROR<span class="op">(</span>IT<span class="op">.</span>insertHookBefore<span class="op">(</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>                MI<span class="op">,</span> LUTHIER_GET_HOOK_HANDLE<span class="op">(</span>countInstructionsScalar<span class="op">)));</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>            LUTHIER_RETURN_ON_ERROR<span class="op">(</span>IT<span class="op">.</span>insertHookBefore<span class="op">(</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>                MI<span class="op">,</span> LUTHIER_GET_HOOK_HANDLE<span class="op">(</span>countInstructionsVector<span class="op">),</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span>CountWavefrontLevelConstVal<span class="op">}));</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>        I<span class="op">++;</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> llvm<span class="op">::</span>Error<span class="op">::</span>success<span class="op">();</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">void</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>instrumentAllFunctionsOfLR<span class="op">(</span><span class="at">const</span> hsa<span class="op">::</span>LoadedCodeObjectKernel <span class="op">&amp;</span>Kernel<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> LR <span class="op">=</span> lift<span class="op">(</span>Kernel<span class="op">);</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>  LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span>LR<span class="op">.</span>takeError<span class="op">());</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>  LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>      instrumentAndLoad<span class="op">(</span>Kernel<span class="op">,</span> <span class="op">*</span>LR<span class="op">,</span> instrumentationLoop<span class="op">,</span> <span class="st">"instr_count"</span><span class="op">));</span></span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a><span class="co">/// ... Definition of Luthier HSA/ROCr callbacks goes here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Luthier tools are written in HIP/C++. This example tool first calls the <code>lift</code> function on the kernel of interest to obtain an instance of <code>LiftedRepresentation</code>. It then uses the <code>instrumentAndLoad</code> function to instrument the kernel and load it into ROCr. The <code>instrumentationLoop</code> is a lambda function that allows direct modification of the <code>LR</code> (the one inside the <code>instrumentAllFunctionsOfLR</code> is immutable) and population of an <code>InstrumentationTask</code> by calling the <code>insertHookBefore</code> function, letting the tool know that we want to insert a call to an instrumentation function (also called hooks).</p>
<p>Some special macros used in Luthier tools are as follows: 1. <code>MARK_LUTHIER_DEVICE_MODULE</code> has the following definition: <code>c++     #define MARK_LUTHIER_DEVICE_MODULE \     __attribute__((managed, used)) char __luthier_reserved = 0;</code> This macro ensures the device module of the Luthier tool is easily identifiable by the Luthier runtime. Also the managed variable ensures that our device module will be loaded right before the first HIP kernel launch. In some instances where the target application directly uses the ROCr runtime, we enable eager loading in HIP using a special environment variable to ensure our tool device module is loaded right away. 2. The following macros are related to Luthier “hooks”: <code>c++     #define LUTHIER_HOOK_ANNOTATE \     __attribute__((device, used, annotate("luthier_hook"))) extern "C" void     #define LUTHIER_EXPORT_HOOK_HANDLE(HookName) \     __attribute__((global, used)) extern "C" void __luthier_hook_handle_##HookName(){};         #define LUTHIER_GET_HOOK_HANDLE(HookName)     \     reinterpret_cast&lt;const void *&gt;(__luthier_hook_handle_##HookName)</code> Hook is an special instrumentation function that can be called right before an instruction of a application. It will be inlined inside the call site while ensuring correct register and stack usage. A hook can also call other device functions and they don’t have to be inlined themselves. Hooks can take arguments to Register values and LLVM <code>Constant</code>s (e.g.&nbsp;<code>countInstructionsVector</code> takes a bool argument which is setup inside <code>instrumentationLoop</code>).</p>
<pre><code>As device functions in HIP don't get a handle accessible from the host code, the `LUTHIER_EXPORT_HOOK_HANDLE` macro creates a host-accessible dummy handle that can be used by the host logic using  `LUTHIER_GET_HOOK_HANDLE`. The `__attribute__(used)` ensures the compiler doesn't optimize these symbols away, as they are needed for Luthier's correct functionality.</code></pre>
<ol start="3" type="1">
<li><p>Luthier doesn’t allow usage of inline assembly inside its hooks or any of its called device functions as their register usage cannot be analyzed until the very last step of code generation; Instead, it introduces a new concept called a “Luthier Intrinsic”. Luthier intrinsics are meant to behave like LLVM intrinsics, as they end up translating to a sequence of low-level code. Luthier itself has a set of pre-implemented intrinsics, including <code>luthier::readReg</code> and <code>luthier::writeReg</code>, which read and write values to the registers. In this example, we use the <code>luthier::writeExec</code> intrinsic: ```c++ #define LUTHIER_INTRINSIC_ANNOTATE<br>
<strong>attribute</strong>((device, noinline, annotate(“luthier_intrinsic”)))</p>
<p>template <typename t=""> <strong>attribute</strong>((device, always_inline)) void doNotOptimize(T const &amp;Value) { <strong>asm</strong> <strong>volatile</strong>(“” : : “X”(Value) : “memory”); }</typename></p>
<p>LUTHIER_INTRINSIC_ANNOTATE void writeExec(uint64_t Val) { doNotOptimize(Val); } ``<code>The</code>LUTHIER_INTRINSIC_ANNOTATE<code>macro annotates any Luthier intrinsic device functions used in hooks. Since HIP doesn't allow calls to</code>extern<code>device functions (due to lack of support for device functions in the ROCr loader), we need to emit a body for it and ensure the compiler doesn't optimize any of the arguments away and the intrinsic calls away. The</code>doNotOptimize` template device function is used for exactly this purpose, which is borrowed from <a href="https://stackoverflow.com/questions/66795357/google-benchmark-frameworks-donotoptimize">Google Benchmark Framework</a>.</p></li>
</ol>
<p>As mentioned earlier, Luthier does not rely on inserting calls to a pre-compiled instrumentation device function. Luthier instead, embeds a pre-processed LLVM IR bitcode that it embeds inside the device code object. At tool compile time, Luthier utilizes a custom compiler plugin, implemented as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">//===-- EmbedInstrumentationModuleBitcodePass.cpp -------------------------===//</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">//===----------------------------------------------------------------------===//</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">///</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\file</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">/// This file implements the </span><span class="an">\c</span><span class="co"> </span><span class="cv">luthier::EmbedInstrumentationModuleBitcode</span><span class="co"> pass,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">/// used by Luthier tools to preprocess instrumentation modules and embedding</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">/// them inside device code objects.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">//===----------------------------------------------------------------------===//</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">"EmbedInstrumentationModuleBitcodePass.hpp"</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">"llvm/Passes/PassPlugin.h"</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/ADT/StringExtras.h&gt;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Analysis/ValueTracking.h&gt;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Bitcode/BitcodeWriterPass.h&gt;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Demangle/Demangle.h&gt;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/IR/Module.h&gt;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Passes/PassBuilder.h&gt;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Support/AMDGPUAddrSpace.h&gt;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Support/raw_ostream.h&gt;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Transforms/Utils/Cloning.h&gt;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;llvm/Transforms/Utils/ModuleUtils.h&gt;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef DEBUG_TYPE</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DEBUG_TYPE </span><span class="st">"luthier-embed-optimized-bitcode-pass"</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> luthier <span class="op">{</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: Import these variables as well as the static functions from</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="co">//  Luthier proper once the separate compilation issue is resolved</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>ReservedManagedVar <span class="op">=</span> <span class="st">"__luthier_reserved"</span><span class="op">;</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>HookAttribute <span class="op">=</span> <span class="st">"luthier_hook"</span><span class="op">;</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>IntrinsicAttribute <span class="op">=</span> <span class="st">"luthier_intrinsic"</span><span class="op">;</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>HipCUIDPrefix <span class="op">=</span> <span class="st">"__hip_cuid_"</span><span class="op">;</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a><span class="co">/// Builds a </span><span class="an">\c</span><span class="co"> </span><span class="cv">llvm::CallInst</span><span class="co"> invoking the intrinsic indicated by</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\p</span><span class="co"> </span><span class="cv">IntrinsicName</span><span class="co"> at the instruction position indicated by the </span><span class="an">\p</span><span class="co"> </span><span class="cv">Builder</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a><span class="co">/// with the given </span><span class="an">\p</span><span class="co"> </span><span class="cv">ReturnType</span><span class="co"> and </span><span class="an">\p</span><span class="co"> </span><span class="cv">Args</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\tparam</span><span class="co"> </span><span class="cv">IArgs</span><span class="co"> Arguments passed to the intrinsic; Can be either a scalar</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="co">/// or a reference to a </span><span class="an">\c</span><span class="co"> </span><span class="cv">llvm::Value</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="cv">M</span><span class="co"> the instrumentation module where the intrinsic will be inserted to</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="cv">Builder</span><span class="co"> the instruction builder used to build the call instruction</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="cv">IntrinsicName</span><span class="co"> the name of the intrinsic</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="cv">ReturnType</span><span class="co"> the return type of the intrinsic call instruction</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="cv">Args</span><span class="co"> the arguments to the intrinsic function</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\return</span><span class="co"> a </span><span class="an">\c</span><span class="co"> </span><span class="cv">llvm::CallInst</span><span class="co"> to the intrinsic function</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>llvm<span class="op">::</span>CallInst <span class="op">*</span>insertCallToIntrinsic<span class="op">(</span>llvm<span class="op">::</span>Module <span class="op">&amp;</span>M<span class="op">,</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>                                      llvm<span class="op">::</span>IRBuilderBase <span class="op">&amp;</span>Builder<span class="op">,</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>                                      llvm<span class="op">::</span>StringRef IntrinsicName<span class="op">,</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>                                      llvm<span class="op">::</span>Type <span class="op">&amp;</span>ReturnType<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">&amp;</span>LLVMContext <span class="op">=</span> Builder<span class="op">.</span>getContext<span class="op">();</span></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Construct the intrinsic's LLVM function type and its argument value</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// list</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">*</span>IntrinsicFuncType <span class="op">=</span> llvm<span class="op">::</span>FunctionType<span class="op">::</span>get<span class="op">(&amp;</span>ReturnType<span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Format the readReg intrinsic function name</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string FormattedIntrinsicName<span class="op">{</span>IntrinsicName<span class="op">};</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>raw_string_ostream IntrinsicNameOS<span class="op">(</span>FormattedIntrinsicName<span class="op">);</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Format the intrinsic function name</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>  IntrinsicNameOS <span class="op">&lt;&lt;</span> <span class="st">"."</span><span class="op">;</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>  IntrinsicFuncType<span class="op">-&gt;</span>getReturnType<span class="op">()-&gt;</span>print<span class="op">(</span>IntrinsicNameOS<span class="op">);</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Create the intrinsic function in the module, or get it if it already</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>  <span class="co">// exists</span></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> ReadRegFunc <span class="op">=</span> M<span class="op">.</span>getOrInsertFunction<span class="op">(</span></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>      FormattedIntrinsicName<span class="op">,</span> IntrinsicFuncType<span class="op">,</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>      llvm<span class="op">::</span>AttributeList<span class="op">().</span>addFnAttribute<span class="op">(</span>LLVMContext<span class="op">,</span> IntrinsicAttribute<span class="op">,</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>                                           IntrinsicName<span class="op">));</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Builder<span class="op">.</span>CreateCall<span class="op">(</span>ReadRegFunc<span class="op">);</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a><span class="co">/// Given a function's mangled name </span><span class="an">\p</span><span class="co"> </span><span class="cv">MangledFuncName</span><span class="co">,</span></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a><span class="co">/// partially demangles it and returns the base function name with its</span></span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a><span class="co">/// namespace prefix </span><span class="an">\n</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a><span class="co">/// For example given a demangled function name int a::b::c</span><span class="kw">&lt;int&gt;</span><span class="co">(), this</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a><span class="co">/// method returns a::b::c</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="cv">MangledFuncName</span><span class="co"> the mangled function name</span></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\return</span><span class="co"> the name of the function with its namespace prefix</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="bu">std::</span>string</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>getDemangledFunctionNameWithNamespace<span class="op">(</span>llvm<span class="op">::</span>StringRef MangledFuncName<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the name of the function, without its template arguments</span></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>ItaniumPartialDemangler Demangler<span class="op">;</span></span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ensure successful partial demangle operation</span></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>Demangler<span class="op">.</span>partialDemangle<span class="op">(</span>MangledFuncName<span class="op">.</span>data<span class="op">()))</span></span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>report_fatal_error<span class="op">(</span><span class="st">"Failed to demangle the intrinsic name "</span> <span class="op">+</span></span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>                             MangledFuncName <span class="op">+</span> <span class="st">"."</span><span class="op">);</span></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Output string</span></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string Out<span class="op">;</span></span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Output string's ostream</span></span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>raw_string_ostream OS<span class="op">(</span>Out<span class="op">);</span></span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> BufferSize<span class="op">;</span></span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>FuncNamespaceBegin <span class="op">=</span></span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>      Demangler<span class="op">.</span>getFunctionDeclContextName<span class="op">(</span><span class="kw">nullptr</span><span class="op">,</span> <span class="op">&amp;</span>BufferSize<span class="op">);</span></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>strlen<span class="op">(</span>FuncNamespaceBegin<span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>    OS <span class="op">&lt;&lt;</span> FuncNamespaceBegin<span class="op">;</span></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>    OS <span class="op">&lt;&lt;</span> <span class="st">"::"</span><span class="op">;</span></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>FuncNameBase <span class="op">=</span> Demangler<span class="op">.</span>getFunctionBaseName<span class="op">(</span><span class="kw">nullptr</span><span class="op">,</span> <span class="op">&amp;</span>BufferSize<span class="op">);</span></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>  OS <span class="op">&lt;&lt;</span> FuncNameBase<span class="op">;</span></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Out<span class="op">;</span></span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a><span class="co">/// Groups the set of annotated values in </span><span class="an">\p</span><span class="co"> </span><span class="cv">M</span><span class="co"> into instrumentation</span></span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a><span class="co">/// hooks and intrinsics of instrumentation hooks </span><span class="an">\n</span></span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="in">\note</span><span class="co"> This function should get updated as Luthier's programming model</span></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a><span class="co">/// gets updated</span></span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="an">[in]</span><span class="co"> </span><span class="cv">M</span><span class="co"> Module to inspect</span></span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="an">[out]</span><span class="co"> </span><span class="cv">Hooks</span><span class="co"> a list of hook functions found in </span><span class="an">\p</span><span class="co"> </span><span class="cv">M</span></span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\param</span><span class="co"> </span><span class="an">[out]</span><span class="co"> </span><span class="cv">Intrinsics</span><span class="co"> a list of intrinsics found in </span><span class="an">\p</span><span class="co"> </span><span class="cv">M</span></span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\return</span><span class="co"> any </span><span class="an">\c</span><span class="co"> </span><span class="cv">llvm::Error</span><span class="co"> encountered during the process</span></span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> llvm<span class="op">::</span>Error</span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a>getAnnotatedValues<span class="op">(</span><span class="at">const</span> llvm<span class="op">::</span>Module <span class="op">&amp;</span>M<span class="op">,</span></span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>                   llvm<span class="op">::</span>SmallVectorImpl<span class="op">&lt;</span>llvm<span class="op">::</span>Function <span class="op">*&gt;</span> <span class="op">&amp;</span>Hooks<span class="op">,</span></span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>                   llvm<span class="op">::</span>SmallVectorImpl<span class="op">&lt;</span>llvm<span class="op">::</span>Function <span class="op">*&gt;</span> <span class="op">&amp;</span>Intrinsics<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> llvm<span class="op">::</span>GlobalVariable <span class="op">*</span>V <span class="op">=</span></span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>      M<span class="op">.</span>getGlobalVariable<span class="op">(</span><span class="st">"llvm.global.annotations"</span><span class="op">);</span></span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>V <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> llvm<span class="op">::</span>Error<span class="op">::</span>success<span class="op">();</span></span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> llvm<span class="op">::</span>ConstantArray <span class="op">*</span>CA <span class="op">=</span> cast<span class="op">&lt;</span>llvm<span class="op">::</span>ConstantArray<span class="op">&gt;(</span>V<span class="op">-&gt;</span>getOperand<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>llvm<span class="op">::</span>Value <span class="op">*</span>Op <span class="op">:</span> CA<span class="op">-&gt;</span>operands<span class="op">())</span> <span class="op">{</span></span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">*</span>CS <span class="op">=</span> cast<span class="op">&lt;</span>llvm<span class="op">::</span>ConstantStruct<span class="op">&gt;(</span>Op<span class="op">);</span></span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The first field of the struct contains a pointer to the annotated</span></span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a>    <span class="co">// variable.</span></span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>Value <span class="op">*</span>AnnotatedVal <span class="op">=</span> CS<span class="op">-&gt;</span>getOperand<span class="op">(</span><span class="dv">0</span><span class="op">)-&gt;</span>stripPointerCasts<span class="op">();</span></span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">*</span>Func <span class="op">=</span> llvm<span class="op">::</span>dyn_cast<span class="op">&lt;</span>llvm<span class="op">::</span>Function<span class="op">&gt;(</span>AnnotatedVal<span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a>      <span class="co">// The second field contains a pointer to a global annotation string.</span></span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>      <span class="kw">auto</span> <span class="op">*</span>GV <span class="op">=</span></span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a>          cast<span class="op">&lt;</span>llvm<span class="op">::</span>GlobalVariable<span class="op">&gt;(</span>CS<span class="op">-&gt;</span>getOperand<span class="op">(</span><span class="dv">1</span><span class="op">)-&gt;</span>stripPointerCasts<span class="op">());</span></span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a>      llvm<span class="op">::</span>StringRef Content<span class="op">;</span></span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a>      llvm<span class="op">::</span>getConstantStringInfo<span class="op">(</span>GV<span class="op">,</span> Content<span class="op">);</span></span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>Content <span class="op">==</span> HookAttribute<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-137"><a href="#cb4-137" aria-hidden="true" tabindex="-1"></a>        Hooks<span class="op">.</span>push_back<span class="op">(</span>Func<span class="op">);</span></span>
<span id="cb4-138"><a href="#cb4-138" aria-hidden="true" tabindex="-1"></a>        LLVM_DEBUG<span class="op">(</span>llvm<span class="op">::</span>dbgs<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"Found hook "</span> <span class="op">&lt;&lt;</span> Func<span class="op">-&gt;</span>getName<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">".</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb4-139"><a href="#cb4-139" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>Content <span class="op">==</span> IntrinsicAttribute<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-140"><a href="#cb4-140" aria-hidden="true" tabindex="-1"></a>        Intrinsics<span class="op">.</span>push_back<span class="op">(</span>Func<span class="op">);</span></span>
<span id="cb4-141"><a href="#cb4-141" aria-hidden="true" tabindex="-1"></a>        LLVM_DEBUG<span class="op">(</span>llvm<span class="op">::</span>dbgs<span class="op">()</span></span>
<span id="cb4-142"><a href="#cb4-142" aria-hidden="true" tabindex="-1"></a>                   <span class="op">&lt;&lt;</span> <span class="st">"Found intrinsic "</span> <span class="op">&lt;&lt;</span> Func<span class="op">-&gt;</span>getName<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">".</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb4-143"><a href="#cb4-143" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb4-144"><a href="#cb4-144" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-145"><a href="#cb4-145" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-146"><a href="#cb4-146" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> llvm<span class="op">::</span>Error<span class="op">::</span>success<span class="op">();</span></span>
<span id="cb4-147"><a href="#cb4-147" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-148"><a href="#cb4-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-149"><a href="#cb4-149" aria-hidden="true" tabindex="-1"></a>llvm<span class="op">::</span>PreservedAnalyses</span>
<span id="cb4-150"><a href="#cb4-150" aria-hidden="true" tabindex="-1"></a>EmbedInstrumentationModuleBitcodePass<span class="op">::</span>run<span class="op">(</span>llvm<span class="op">::</span>Module <span class="op">&amp;</span>M<span class="op">,</span></span>
<span id="cb4-151"><a href="#cb4-151" aria-hidden="true" tabindex="-1"></a>                                           llvm<span class="op">::</span>ModuleAnalysisManager <span class="op">&amp;</span>AM<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-152"><a href="#cb4-152" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>M<span class="op">.</span>getGlobalVariable<span class="op">(</span><span class="st">"llvm.embedded.module"</span><span class="op">,</span> <span class="co">/*AllowInternal=*/</span><span class="kw">true</span><span class="op">))</span></span>
<span id="cb4-153"><a href="#cb4-153" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>report_fatal_error<span class="op">(</span></span>
<span id="cb4-154"><a href="#cb4-154" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Attempted to embed bitcode twice. Are you passing -fembed-bitcode?"</span><span class="op">,</span></span>
<span id="cb4-155"><a href="#cb4-155" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*gen_crash_diag=*/</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb4-156"><a href="#cb4-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-157"><a href="#cb4-157" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>Triple T<span class="op">(</span>M<span class="op">.</span>getTargetTriple<span class="op">());</span></span>
<span id="cb4-158"><a href="#cb4-158" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Only operate on the AMD GCN code objects</span></span>
<span id="cb4-159"><a href="#cb4-159" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>T<span class="op">.</span>getArch<span class="op">()</span> <span class="op">!=</span> llvm<span class="op">::</span>Triple<span class="op">::</span>ArchType<span class="op">::</span>amdgcn<span class="op">)</span></span>
<span id="cb4-160"><a href="#cb4-160" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> llvm<span class="op">::</span>PreservedAnalyses<span class="op">::</span>all<span class="op">();</span></span>
<span id="cb4-161"><a href="#cb4-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-162"><a href="#cb4-162" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Clone the module in order to preprocess it + not interfere with normal</span></span>
<span id="cb4-163"><a href="#cb4-163" aria-hidden="true" tabindex="-1"></a>  <span class="co">// HIP compilation</span></span>
<span id="cb4-164"><a href="#cb4-164" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> ClonedModule <span class="op">=</span> llvm<span class="op">::</span>CloneModule<span class="op">(</span>M<span class="op">);</span></span>
<span id="cb4-165"><a href="#cb4-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-166"><a href="#cb4-166" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Extract all the hooks and intrinsics</span></span>
<span id="cb4-167"><a href="#cb4-167" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>SmallVector<span class="op">&lt;</span>llvm<span class="op">::</span>Function <span class="op">*,</span> <span class="dv">4</span><span class="op">&gt;</span> Hooks<span class="op">;</span></span>
<span id="cb4-168"><a href="#cb4-168" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>SmallVector<span class="op">&lt;</span>llvm<span class="op">::</span>Function <span class="op">*,</span> <span class="dv">4</span><span class="op">&gt;</span> Intrinsics<span class="op">;</span></span>
<span id="cb4-169"><a href="#cb4-169" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> Err <span class="op">=</span> getAnnotatedValues<span class="op">(*</span>ClonedModule<span class="op">,</span> Hooks<span class="op">,</span> Intrinsics<span class="op">))</span></span>
<span id="cb4-170"><a href="#cb4-170" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>report_fatal_error<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>Err<span class="op">),</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb4-171"><a href="#cb4-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-172"><a href="#cb4-172" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Remove the annotations variable from the Module now that it is processed</span></span>
<span id="cb4-173"><a href="#cb4-173" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> AnnotationGV <span class="op">=</span></span>
<span id="cb4-174"><a href="#cb4-174" aria-hidden="true" tabindex="-1"></a>      ClonedModule<span class="op">-&gt;</span>getGlobalVariable<span class="op">(</span><span class="st">"llvm.global.annotations"</span><span class="op">);</span></span>
<span id="cb4-175"><a href="#cb4-175" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>AnnotationGV<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-176"><a href="#cb4-176" aria-hidden="true" tabindex="-1"></a>    AnnotationGV<span class="op">-&gt;</span>dropAllReferences<span class="op">();</span></span>
<span id="cb4-177"><a href="#cb4-177" aria-hidden="true" tabindex="-1"></a>    AnnotationGV<span class="op">-&gt;</span>eraseFromParent<span class="op">();</span></span>
<span id="cb4-178"><a href="#cb4-178" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-179"><a href="#cb4-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-180"><a href="#cb4-180" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Remove the llvm.used and llvm.compiler.use variable list</span></span>
<span id="cb4-181"><a href="#cb4-181" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;</span>VarName <span class="op">:</span> <span class="op">{</span><span class="st">"llvm.compiler.used"</span><span class="op">,</span> <span class="st">"llvm.used"</span><span class="op">})</span> <span class="op">{</span></span>
<span id="cb4-182"><a href="#cb4-182" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> LLVMUsedVar <span class="op">=</span> ClonedModule<span class="op">-&gt;</span>getGlobalVariable<span class="op">(</span>VarName<span class="op">);</span></span>
<span id="cb4-183"><a href="#cb4-183" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>LLVMUsedVar <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-184"><a href="#cb4-184" aria-hidden="true" tabindex="-1"></a>      LLVMUsedVar<span class="op">-&gt;</span>dropAllReferences<span class="op">();</span></span>
<span id="cb4-185"><a href="#cb4-185" aria-hidden="true" tabindex="-1"></a>      LLVMUsedVar<span class="op">-&gt;</span>eraseFromParent<span class="op">();</span></span>
<span id="cb4-186"><a href="#cb4-186" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-187"><a href="#cb4-187" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-188"><a href="#cb4-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-189"><a href="#cb4-189" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Give each Hook function a "hook" attribute</span></span>
<span id="cb4-190"><a href="#cb4-190" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> Hook <span class="op">:</span> Hooks<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-191"><a href="#cb4-191" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: remove the always inline attribute once Hooks support the anyreg</span></span>
<span id="cb4-192"><a href="#cb4-192" aria-hidden="true" tabindex="-1"></a>    <span class="co">// calling convention</span></span>
<span id="cb4-193"><a href="#cb4-193" aria-hidden="true" tabindex="-1"></a>    Hook<span class="op">-&gt;</span>addFnAttr<span class="op">(</span>HookAttribute<span class="op">);</span></span>
<span id="cb4-194"><a href="#cb4-194" aria-hidden="true" tabindex="-1"></a>    Hook<span class="op">-&gt;</span>removeFnAttr<span class="op">(</span>llvm<span class="op">::</span>Attribute<span class="op">::</span>OptimizeNone<span class="op">);</span></span>
<span id="cb4-195"><a href="#cb4-195" aria-hidden="true" tabindex="-1"></a>    Hook<span class="op">-&gt;</span>removeFnAttr<span class="op">(</span>llvm<span class="op">::</span>Attribute<span class="op">::</span>NoInline<span class="op">);</span></span>
<span id="cb4-196"><a href="#cb4-196" aria-hidden="true" tabindex="-1"></a>    Hook<span class="op">-&gt;</span>addFnAttr<span class="op">(</span>llvm<span class="op">::</span>Attribute<span class="op">::</span>AlwaysInline<span class="op">);</span></span>
<span id="cb4-197"><a href="#cb4-197" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-198"><a href="#cb4-198" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Remove the body of each intrinsic function and make them extern</span></span>
<span id="cb4-199"><a href="#cb4-199" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Also demangle the name and format it similar to LLVM intrinsics</span></span>
<span id="cb4-200"><a href="#cb4-200" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> Intrinsic <span class="op">:</span> Intrinsics<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-201"><a href="#cb4-201" aria-hidden="true" tabindex="-1"></a>    Intrinsic<span class="op">-&gt;</span>deleteBody<span class="op">();</span></span>
<span id="cb4-202"><a href="#cb4-202" aria-hidden="true" tabindex="-1"></a>    Intrinsic<span class="op">-&gt;</span>setComdat<span class="op">(</span><span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb4-203"><a href="#cb4-203" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>StringRef MangledIntrinsicName <span class="op">=</span> Intrinsic<span class="op">-&gt;</span>getName<span class="op">();</span></span>
<span id="cb4-204"><a href="#cb4-204" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Format the intrinsic name</span></span>
<span id="cb4-205"><a href="#cb4-205" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string FormattedIntrinsicName<span class="op">;</span></span>
<span id="cb4-206"><a href="#cb4-206" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>raw_string_ostream FINOS<span class="op">(</span>FormattedIntrinsicName<span class="op">);</span></span>
<span id="cb4-207"><a href="#cb4-207" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string DemangledIntrinsicName <span class="op">=</span></span>
<span id="cb4-208"><a href="#cb4-208" aria-hidden="true" tabindex="-1"></a>        getDemangledFunctionNameWithNamespace<span class="op">(</span>MangledIntrinsicName<span class="op">);</span></span>
<span id="cb4-209"><a href="#cb4-209" aria-hidden="true" tabindex="-1"></a>    FINOS <span class="op">&lt;&lt;</span> DemangledIntrinsicName<span class="op">;</span></span>
<span id="cb4-210"><a href="#cb4-210" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the output type if it's not void</span></span>
<span id="cb4-211"><a href="#cb4-211" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">*</span>ReturnType <span class="op">=</span> Intrinsic<span class="op">-&gt;</span>getReturnType<span class="op">();</span></span>
<span id="cb4-212"><a href="#cb4-212" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>ReturnType<span class="op">-&gt;</span>isVoidTy<span class="op">())</span> <span class="op">{</span></span>
<span id="cb4-213"><a href="#cb4-213" aria-hidden="true" tabindex="-1"></a>      FINOS <span class="op">&lt;&lt;</span> <span class="st">"."</span><span class="op">;</span></span>
<span id="cb4-214"><a href="#cb4-214" aria-hidden="true" tabindex="-1"></a>      ReturnType<span class="op">-&gt;</span>print<span class="op">(</span>FINOS<span class="op">);</span></span>
<span id="cb4-215"><a href="#cb4-215" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-216"><a href="#cb4-216" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the argument types</span></span>
<span id="cb4-217"><a href="#cb4-217" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;</span>Arg <span class="op">:</span> Intrinsic<span class="op">-&gt;</span>args<span class="op">())</span> <span class="op">{</span></span>
<span id="cb4-218"><a href="#cb4-218" aria-hidden="true" tabindex="-1"></a>      FINOS <span class="op">&lt;&lt;</span> <span class="st">"."</span><span class="op">;</span></span>
<span id="cb4-219"><a href="#cb4-219" aria-hidden="true" tabindex="-1"></a>      Arg<span class="op">.</span>getType<span class="op">()-&gt;</span>print<span class="op">(</span>FINOS<span class="op">);</span></span>
<span id="cb4-220"><a href="#cb4-220" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-221"><a href="#cb4-221" aria-hidden="true" tabindex="-1"></a>    Intrinsic<span class="op">-&gt;</span>addFnAttr<span class="op">(</span>IntrinsicAttribute<span class="op">,</span> DemangledIntrinsicName<span class="op">);</span></span>
<span id="cb4-222"><a href="#cb4-222" aria-hidden="true" tabindex="-1"></a>    Intrinsic<span class="op">-&gt;</span>setName<span class="op">(</span>FormattedIntrinsicName<span class="op">);</span></span>
<span id="cb4-223"><a href="#cb4-223" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-224"><a href="#cb4-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-225"><a href="#cb4-225" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Remove all kernels that are meant to serve as a host handle</span></span>
<span id="cb4-226"><a href="#cb4-226" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>F <span class="op">:</span> llvm<span class="op">::</span>make_early_inc_range<span class="op">(</span>ClonedModule<span class="op">-&gt;</span>functions<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb4-227"><a href="#cb4-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-228"><a href="#cb4-228" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>F<span class="op">.</span>getCallingConv<span class="op">()</span> <span class="op">==</span> llvm<span class="op">::</span>CallingConv<span class="op">::</span>AMDGPU_KERNEL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-229"><a href="#cb4-229" aria-hidden="true" tabindex="-1"></a>      F<span class="op">.</span>dropAllReferences<span class="op">();</span></span>
<span id="cb4-230"><a href="#cb4-230" aria-hidden="true" tabindex="-1"></a>      F<span class="op">.</span>eraseFromParent<span class="op">();</span></span>
<span id="cb4-231"><a href="#cb4-231" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-232"><a href="#cb4-232" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-233"><a href="#cb4-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-234"><a href="#cb4-234" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Convert all global variables to extern, remove any managed variable</span></span>
<span id="cb4-235"><a href="#cb4-235" aria-hidden="true" tabindex="-1"></a>  <span class="co">// initializers</span></span>
<span id="cb4-236"><a href="#cb4-236" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Remove any unnecessary variables (e.g. "llvm.metadata")</span></span>
<span id="cb4-237"><a href="#cb4-237" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Extract the CUID for identification</span></span>
<span id="cb4-238"><a href="#cb4-238" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>GV <span class="op">:</span> llvm<span class="op">::</span>make_early_inc_range<span class="op">(</span>ClonedModule<span class="op">-&gt;</span>globals<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb4-239"><a href="#cb4-239" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> GVName <span class="op">=</span> GV<span class="op">.</span>getName<span class="op">();</span></span>
<span id="cb4-240"><a href="#cb4-240" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>GVName<span class="op">.</span>ends_with<span class="op">(</span><span class="st">".managed"</span><span class="op">)</span> <span class="op">||</span> GVName <span class="op">==</span> ReservedManagedVar <span class="op">||</span></span>
<span id="cb4-241"><a href="#cb4-241" aria-hidden="true" tabindex="-1"></a>        GV<span class="op">.</span>getSection<span class="op">()</span> <span class="op">==</span> <span class="st">"llvm.metadata"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-242"><a href="#cb4-242" aria-hidden="true" tabindex="-1"></a>      GV<span class="op">.</span>dropAllReferences<span class="op">();</span></span>
<span id="cb4-243"><a href="#cb4-243" aria-hidden="true" tabindex="-1"></a>      GV<span class="op">.</span>eraseFromParent<span class="op">();</span></span>
<span id="cb4-244"><a href="#cb4-244" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(!</span>GVName<span class="op">.</span>starts_with<span class="op">(</span>HipCUIDPrefix<span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-245"><a href="#cb4-245" aria-hidden="true" tabindex="-1"></a>      GV<span class="op">.</span>setInitializer<span class="op">(</span><span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb4-246"><a href="#cb4-246" aria-hidden="true" tabindex="-1"></a>      GV<span class="op">.</span>setLinkage<span class="op">(</span>llvm<span class="op">::</span>GlobalValue<span class="op">::</span>ExternalLinkage<span class="op">);</span></span>
<span id="cb4-247"><a href="#cb4-247" aria-hidden="true" tabindex="-1"></a>      GV<span class="op">.</span>setVisibility<span class="op">(</span>llvm<span class="op">::</span>GlobalValue<span class="op">::</span>DefaultVisibility<span class="op">);</span></span>
<span id="cb4-248"><a href="#cb4-248" aria-hidden="true" tabindex="-1"></a>      GV<span class="op">.</span>setDSOLocal<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb4-249"><a href="#cb4-249" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-250"><a href="#cb4-250" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-251"><a href="#cb4-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-252"><a href="#cb4-252" aria-hidden="true" tabindex="-1"></a>  LLVM_DEBUG<span class="op">(</span>llvm<span class="op">::</span>dbgs<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"Embedded Module "</span> <span class="op">&lt;&lt;</span> ClonedModule<span class="op">-&gt;</span>getName<span class="op">()</span></span>
<span id="cb4-253"><a href="#cb4-253" aria-hidden="true" tabindex="-1"></a>                          <span class="op">&lt;&lt;</span> <span class="st">" dump: "</span><span class="op">);</span></span>
<span id="cb4-254"><a href="#cb4-254" aria-hidden="true" tabindex="-1"></a>  LLVM_DEBUG<span class="op">(</span>ClonedModule<span class="op">-&gt;</span>print<span class="op">(</span>llvm<span class="op">::</span>dbgs<span class="op">(),</span> <span class="kw">nullptr</span><span class="op">));</span></span>
<span id="cb4-255"><a href="#cb4-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-256"><a href="#cb4-256" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>SmallVector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> Data<span class="op">;</span></span>
<span id="cb4-257"><a href="#cb4-257" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>raw_svector_ostream OS<span class="op">(</span>Data<span class="op">);</span></span>
<span id="cb4-258"><a href="#cb4-258" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> PA <span class="op">=</span> llvm<span class="op">::</span>BitcodeWriterPass<span class="op">(</span>OS<span class="op">).</span>run<span class="op">(*</span>ClonedModule<span class="op">,</span> AM<span class="op">);</span></span>
<span id="cb4-259"><a href="#cb4-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-260"><a href="#cb4-260" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>embedBufferInModule<span class="op">(</span></span>
<span id="cb4-261"><a href="#cb4-261" aria-hidden="true" tabindex="-1"></a>      M<span class="op">,</span> llvm<span class="op">::</span>MemoryBufferRef<span class="op">(</span>llvm<span class="op">::</span>toStringRef<span class="op">(</span>Data<span class="op">),</span> <span class="st">"ModuleData"</span><span class="op">),</span></span>
<span id="cb4-262"><a href="#cb4-262" aria-hidden="true" tabindex="-1"></a>      <span class="st">".llvmbc"</span><span class="op">);</span></span>
<span id="cb4-263"><a href="#cb4-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-264"><a href="#cb4-264" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> PA<span class="op">;</span></span>
<span id="cb4-265"><a href="#cb4-265" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-266"><a href="#cb4-266" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// namespace luthier</span></span>
<span id="cb4-267"><a href="#cb4-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-268"><a href="#cb4-268" aria-hidden="true" tabindex="-1"></a>llvm<span class="op">::</span>PassPluginLibraryInfo getEmbedLuthierBitcodePassPluginInfo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-269"><a href="#cb4-269" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> Callback <span class="op">=</span> <span class="op">[](</span>llvm<span class="op">::</span>PassBuilder <span class="op">&amp;</span>PB<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-270"><a href="#cb4-270" aria-hidden="true" tabindex="-1"></a>    PB<span class="op">.</span>registerOptimizerLastEPCallback<span class="op">(</span></span>
<span id="cb4-271"><a href="#cb4-271" aria-hidden="true" tabindex="-1"></a>        <span class="op">[](</span>llvm<span class="op">::</span>ModulePassManager <span class="op">&amp;</span>MPM<span class="op">,</span> llvm<span class="op">::</span>OptimizationLevel Opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-272"><a href="#cb4-272" aria-hidden="true" tabindex="-1"></a>          MPM<span class="op">.</span>addPass<span class="op">(</span>luthier<span class="op">::</span>EmbedInstrumentationModuleBitcodePass<span class="op">());</span></span>
<span id="cb4-273"><a href="#cb4-273" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb4-274"><a href="#cb4-274" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb4-275"><a href="#cb4-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-276"><a href="#cb4-276" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">{</span>LLVM_PLUGIN_API_VERSION<span class="op">,</span> <span class="st">"pre-process-and-embed-luthier-bitcode"</span><span class="op">,</span></span>
<span id="cb4-277"><a href="#cb4-277" aria-hidden="true" tabindex="-1"></a>          LLVM_VERSION_STRING<span class="op">,</span> Callback<span class="op">};</span></span>
<span id="cb4-278"><a href="#cb4-278" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-279"><a href="#cb4-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-280"><a href="#cb4-280" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef LLVM_LUTHIER_TOOL_COMPILE_PLUGIN_LINK_INTO_TOOLS</span></span>
<span id="cb4-281"><a href="#cb4-281" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">"C"</span> LLVM_ATTRIBUTE_WEAK <span class="op">::</span>llvm<span class="op">::</span>PassPluginLibraryInfo</span>
<span id="cb4-282"><a href="#cb4-282" aria-hidden="true" tabindex="-1"></a>llvmGetPassPluginInfo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-283"><a href="#cb4-283" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> getEmbedLuthierBitcodePassPluginInfo<span class="op">();</span></span>
<span id="cb4-284"><a href="#cb4-284" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-285"><a href="#cb4-285" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The compiler plugin peforms the following actions: 1. It only operates on AMDGPU code objects and not the host executable. 2. It clones the device code’s <code>llvm::Module</code>. It doesn’t interfer with the original compilation as the next steps will cause Clang/LLVM to be unhappy. 3. Using annotations done in the tool’s source code, we identify the hooks and intrinsics inside the device module, and then remove the <code>llvm::GlobalVariable</code> that holds the annotated values. 4. Removes the <code>llvm.compiler.use</code> and <code>llvm.used</code> global variables, as they don’t matter in the instrumentation process. 5. Gives each hook device function a “luthier_hook” attribute so that they are easily identified later on. They are also given forced inlined attributes, as hooks are always meant to be inlined at the instrumentation point. 6. Removes the body of all Luthier intrinsic functions, and re-format their CXX Itanium mangled names to look similar to LLVM intrinsics. 7. Removes the “dummy” hook handles defined using the <code>LUTHIER_EXPORT_HOOK_HANDLE</code> macro. 8. Makes all the global variables extern, as the non-cloned module will be the one defining them. 9. Finally, the cloned module will be embedded inside a non-loadable section of the device code object called <code>.llvmbc</code>.</p>
</section>
</section>
<section id="generating-instrumented-code" class="level2">
<h2 class="anchored" data-anchor-id="generating-instrumented-code">Generating Instrumented Code</h2>
<p>At runtime, calling the function <code>luthier::instrumentAndLoad</code> will generate a newly instrumented code object and loads it into the ROCm runtime for execution. It first clones the <code>LiftedRepresentation</code> to allow it to be writable (the original copy is cached by Luthier) and then runs the passed lambda (called the mutator) on the <code>LiftedRepresentation</code>. The mutator allows the <code>LiftedRepresentation</code> to be directly modified using LLVM CodeGen APIs, or one can also use the <code>InstrumentationTask</code> to insert calls to hooks before instructions.</p>
<p>After the mutator is done executing, Luthier’s instrumentation code generation executes, which is as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;[</span>LCOHandle<span class="op">,</span> LCOModule<span class="op">]</span> <span class="op">:</span> LR<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    hsa<span class="op">::</span>LoadedCodeObject LCO<span class="op">(</span>LCOHandle<span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> Agent <span class="op">=</span> LCO<span class="op">.</span>getAgent<span class="op">();</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    LUTHIER_RETURN_ON_ERROR<span class="op">(</span>Agent<span class="op">.</span>takeError<span class="op">());</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">&amp;</span>TM <span class="op">=</span> <span class="op">*</span>LR<span class="op">.</span>getTM<span class="op">(</span>LCOHandle<span class="op">);</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Load the bitcode of the instrumentation module into the</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Lifted Representation's context</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>llvm<span class="op">::</span>Module<span class="op">&gt;</span> IModule<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    LUTHIER_RETURN_ON_ERROR<span class="op">(</span>Task<span class="op">.</span>getModule<span class="op">()</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                                <span class="op">.</span>readBitcodeIntoContext<span class="op">(</span>LR<span class="op">.</span>getContext<span class="op">(),</span> <span class="op">*</span>Agent<span class="op">)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                                <span class="op">.</span>moveInto<span class="op">(</span>IModule<span class="op">));</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Instantiate the Module PM and analysis in charge of running the</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// IR pipeline for the instrumentation module</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We keep them here because we will need the analysis done at the IR</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// stage at the code generation stage, which for now we have to use</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the legacy pass manager for</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>LoopAnalysisManager ILAM<span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>FunctionAnalysisManager IFAM<span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>CGSCCAnalysisManager ICGAM<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>ModuleAnalysisManager IMAM<span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>ModulePassManager IPM<span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Instantiate the Legacy PM for running the modified codegen pipeline</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on the instrumentation module and MMI</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We allocate this on the heap to have the most control over its lifetime,</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as if it goes out of scope it will also delete the instrumentation</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// MMI</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> LegacyIPM <span class="op">=</span> <span class="kw">new</span> llvm<span class="op">::</span>legacy<span class="op">::</span>PassManager<span class="op">();</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Instrumentation module MMI wrapper pass, which will house the final</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// generate instrumented code</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">*</span>IMMIWP <span class="op">=</span> <span class="kw">new</span> llvm<span class="op">::</span>MachineModuleInfoWrapperPass<span class="op">(&amp;</span>TM<span class="op">);</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a module analysis manager for the target code</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>ModuleAnalysisManager TargetMAM<span class="op">;</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a new Module pass manager, in charge of running the entire</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// pipeline</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>ModulePassManager TargetMPM<span class="op">;</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the pass instrumentation analysis as it is required by the new PM</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">(</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">[&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> llvm<span class="op">::</span>PassInstrumentationAnalysis<span class="op">();</span> <span class="op">});</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the MMI Analysis pass, pointing to the target app's lifted MMI</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">(</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">[&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> llvm<span class="op">::</span>MachineModuleAnalysis<span class="op">(</span>LCOModule<span class="op">.</span>second<span class="op">);</span> <span class="op">});</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the instrumentation PM analysis</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">([&amp;]()</span> <span class="op">{</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> IModulePMAnalysis<span class="op">(*</span>IModule<span class="op">,</span> IPM<span class="op">,</span> IMAM<span class="op">,</span> ILAM<span class="op">,</span> IFAM<span class="op">,</span> ICGAM<span class="op">);</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the LR Analysis pass</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">([&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> LiftedRepresentationAnalysis<span class="op">(</span>LR<span class="op">);</span> <span class="op">});</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the LCO Analysis pass</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">([&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> LoadedCodeObjectAnalysis<span class="op">(</span>LCO<span class="op">);</span> <span class="op">});</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the LR Register Liveness pass</span></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">([&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> LRRegLivenessAnalysis<span class="op">();</span> <span class="op">});</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the LR Callgraph analysis pass</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">([&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> LRCallGraphAnalysis<span class="op">();</span> <span class="op">});</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the MMI-wide Slot indexes analysis pass</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">([&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> MMISlotIndexesAnalysis<span class="op">();</span> <span class="op">});</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the State Value Array storage and load analysis pass</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">(</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">[&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> LRStateValueStorageAndLoadLocationsAnalysis<span class="op">();</span> <span class="op">});</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the Function Preamble Descriptor Analysis pass</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>    TargetMAM<span class="op">.</span>registerPass<span class="op">(</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">[&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> FunctionPreambleDescriptorAnalysis<span class="op">();</span> <span class="op">});</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the IR pipeline for the instrumentation module</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    TargetMPM<span class="op">.</span>addPass<span class="op">(</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>        RunIRPassesOnIModulePass<span class="op">(</span>Task<span class="op">,</span> IntrinsicsProcessors<span class="op">,</span> TM<span class="op">,</span> <span class="op">*</span>IModule<span class="op">));</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the MIR pipeline for the instrumentation module</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>    TargetMPM<span class="op">.</span>addPass<span class="op">(</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>        RunMIRPassesOnIModulePass<span class="op">(</span>TM<span class="op">,</span> <span class="op">*</span>IModule<span class="op">,</span> <span class="op">*</span>IMMIWP<span class="op">,</span> <span class="op">*</span>LegacyIPM<span class="op">));</span></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the kernel pre-amble emission pass</span></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>    TargetMPM<span class="op">.</span>addPass<span class="op">(</span>PrePostAmbleEmitter<span class="op">());</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the lifted representation patching pass</span></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>    TargetMPM<span class="op">.</span>addPass<span class="op">(</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>        PatchLiftedRepresentationPass<span class="op">(*</span>IModule<span class="op">,</span> IMMIWP<span class="op">-&gt;</span>getMMI<span class="op">()));</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>    TargetMPM<span class="op">.</span>run<span class="op">(</span>LCOModule<span class="op">.</span>first<span class="op">,</span> TargetMAM<span class="op">);</span></span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: remove this once the new MMI makes it to LLVM master</span></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> LegacyIPM<span class="op">;</span></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>Create an instrumentation <code>llvm::Module</code> (i.e.&nbsp;<code>IModule</code>) and read the bitcode we embedded in the previous step into it.</li>
<li>Create two separate pass managers: One in charge of managing the target application’s MIR and analysis passes on it, and one in charge of generating IR/MIR for the instrumentation logic and their analysis passes.</li>
<li>Add the following analysis to the Target App PM:
<ol type="1">
<li><code>LRRegLivenessAnalysis</code>: Which analyzes the register liveness of the application using data flow analysis covered in class, though in some cases this is not enough to ensure liveness for VGPRs. I’m currently working on creating an alternate CFG to run liveness analysis on for VGPRs that also take into account changes in the <code>EXEC</code> mask value.</li>
<li><code>LRCallGraphAnalysis</code>, which naively recovers the call graph of the target application. This is used in conjunction with the register liveness analysis, ensuring correct register reuse in callee instrumentation points.</li>
<li><code>MMISlotIndexesAnalysis</code> assigns a slot index to each instruction and basic block inside the target application. It is used with the next analysis, <code>LRStateValueStorageAndLoadLocationsAnalysis</code>.</li>
<li><code>LRStateValueStorageAndLoadLocationsAnalysis</code> attempts to find a place to store the SVA (defined previously) with unused/dead registers. Luthier has many ways to store the SVA, depending on the target of choice:
<ol type="1">
<li>An Unused VGPR.</li>
<li>(If target supports using AGPRs as operands in vector instructions, post-gfx90A) an unused AGPR.</li>
<li>(pre-gfx908) two unused AGPR, with one serving as a spill spot for the app’s live VGPR.</li>
<li>(pre-gfx908) one unused AGPR, with 3 unused SGPRs, with the AGPR holding the SVA, two SGPRs holding the correct flat scratch register value, and a third SGPR to point to the bottom of the instrumentation stack.</li>
<li>(post MI300, architected flat scratch) single SGPR that points to the bottom of the instrumentation stack.</li>
<li>(pre-MI300, absolute flat scratch) 3 unused SGPRs, with two SGPRs holding the correct flat scratch register value, and a third SGPR to point to the bottom of the instrumentation stack. Each storage scheme has to have code for loading, and storing the SVA, as well as code to move itself to another storage scheme, and has enough registers/resources to do so without clobbering any of the application registers (especially the <code>SCC</code> bit). To minimize additional instructions injected inside the target application, this analysis first attempts to find a fixed storage for the SVA. In extreme cases where the attempt is not successful, it will then figure out where to store the SVA at each slot index of the application using the register liveness analysis. If, at any point in this analysis, no suitable SVA storage is found, instrumentation fails, as without an SVA there is no way to recover the instrumentation stack. Besides storing the SVA, this pass also decides where the SVA will be loaded at each “injected payload” (defined later in <code>IModuleIRGeneratorPass</code>). The SVA will be then kept at a fixed location and will not be spilled.</li>
</ol></li>
<li><code>FunctionPreambleDescriptorAnalysis</code>, <code>LiftedRepresentationAnalysis</code>, and <code>LoadedCodeObjectAnalysis</code> are storage for the preamble descriptor, the <code>LiftedRepresentation</code> and the <code>LoadedCodeObject</code> being operated on. The <code>FunctionPreambleDescriptor</code> aggregates information for the required resources for instrumentation function; For example, if usage of stack is detected in the instrumentation code, the preamble descriptor will be signaled to emit code that sets up the SVA and access to instrumentation stack.</li>
</ol></li>
<li>Runs IR passes on the instrumentation Module, which runs the following passes on the <code>IModule</code>:
<ol type="1">
<li><code>IModuleIRGeneratorPass</code> takes the <code>InstrumentationTask</code> description and peforms the following tasks for each instrumentation point (target application’s instruction):
<ol type="1">
<li>Creates a new <code>llvm::Function</code> with the <code>C</code> calling convention with no input or output arguments and a <code>Naked</code> attribute to prevent a frame to emitted for them (we will emit a custom frame ourselves). We call these functions an “Injected Payload”.</li>
<li>Inside each injected payload it inserts <code>llvm::CallInst</code>s to the hooks with the specified arguments; Register values are done with calls to <code>luthier::ReadReg</code> intrinsics; For constant values, the <code>llvm::Constant</code>s passed to the instrumentation task will be directly used.</li>
</ol></li>
<li>The normal LLVM IR optimization pipeline.</li>
<li><code>ProcessIntrinsicsAtIRLevelPass</code> applies the IR lowering callback for each Luthier intrinsic. The callback:
<ol type="1">
<li>Replaces each call to a Luthier intrinsic with a call to a “dummy inline assembly” inside the IR</li>
<li>Enforces the type of register (i.e.&nbsp;S/A/V) its inputs and outputs are required to be.</li>
<li>Can also analyse the arguments passed to it, and based on them request access to a physical register. As inline assembly remains unchanged during both ISEL and CodeGen pipelines, we use the inline assembly string as a placeholder to identify it later done the code generation pipeline.</li>
</ol></li>
</ol></li>
<li>Runs the Code Gen Passes on the instrumentation Module:
<ol type="1">
<li>Run the LLVM ISEL passes on the <code>IModule</code> to generate the <code>IMMI</code>, the instrumentation module’s <code>MachineModuleInfo</code> which will house the <code>MIR</code> of the <code>IModule.</code></li>
<li><code>PhysicalRegAccessVirtualizationPass</code> essentially generates valid MIR code to enforce register constraints:
<ol type="1">
<li>Ensures the SVA is kept in a single place by declaring it as a live-in at the entry block, and adding the SVA VGPR as an implicit operand to all return instructions in all return blocks. They count as a valid def and use, respectively.</li>
<li>The set of registers live at the insertion point, as well as registers accessed by the injected payload will be divided into 32-bit registers; For example, if <code>s[0:1]</code> is live, then we divide it into <code>s0</code> and <code>s1</code>. If <code>s0_lo</code> is live, then we set <code>s0</code> to be live.</li>
<li>If registers <code>s0</code>, <code>s1</code>, <code>s2</code>, <code>s3</code>, <code>FS_LO</code>, <code>FS_HI</code>, <code>s32</code> are live-ins, then they are copied into lanes of the SVA on entry in the <code>InjectedPayloadPEIPass</code>, and then copied back to their original location at the end of all exit blocks. These registers always have a fixed spill slot, as the injected payload expects that these registers are always free for its frame usage.</li>
<li>All other live-in registers and accessed physical registers will be copied to a new virtual register in the entry block, and then copied back from the virtual register to their original place in all return blocks. This basically allows the register allocator to spill the registers whenever it deems it necessary, reducing the number of times the register is spilled.</li>
<li>As accessed physical registers are now in virtual registers, an <code>llvm::SSAUpdator</code> is used for each physical register to manifest new virtual register values for them inside each <code>llvm::MachineBasicBlock</code>. That way, intrinsics that requested access to these physical registers can get access to their virtual registers.</li>
</ol></li>
<li><code>IntrinsicMIRLoweringPass</code> runs the MIR lowering stage of Luthier intrinsics. In this stage, each intrinsic will run a callback with the information saved from its IR lowering stage that will result in a sequence of MI instructions in valid SSA form that operate on their input/output registers. These callbacks can request access to the virtual register associated with the physical registers they have requested before. They can also signal <code>IntrinsicMIRLoweringPass</code> that a physical register’s virtual register is written to and requires an update to retain the SSA form of the instrumentation MIR.</li>
<li>Normal LLVM Machine Passes are run, with the <code>InjectedPayloadPEIPass</code> run right before the function prologue/epilogue insertion pass. This pass will analyse each injected payload after register allocation/rewrite to detect explicit uses of the SVA register. If an explicit use is detected, then it will emit code to load and store the SVA on entry and exit respectively. If stack usage in the injected payload is detected the <code>FunctionPreambleDescriptor</code> will be signaled that the instrumented kernel requires stack usage and must be setup in the beginning of the kernel.</li>
</ol></li>
<li>Runs the <code>PrePostAmbleEmitter</code> pass, which takes the information gathered in <code>FunctionPreambleDescriptor</code> and <code>LRStateValueStorageAndLoadLocationsAnalysis</code> to do the following on every kernel:
<ol type="1">
<li>Determines whether SVA setup is required; If not, it won’t do anything to the code.</li>
<li>If SVA setup is required, it will see if this was due to requiring access to scratch; If so, it forcably enables it, emits code that sets up scratch access, and then saves it in fixed lanes of the SVA. It then proceeds to restore the original SGPR kernel arguments back to their original place.</li>
</ol></li>
<li>Runs the <code>PatchLiftedRepresentationPass</code>, which will “patch” the final instrumentation logic before their instrumentation point, copying over the generated instructions into the target application. Note that we have to keep the “target” application and “instrumentation” application instructions separate, as there is no good way of enforcing immutability of the “target” application instructions.</li>
</ol>
<p>The final result is an instrumented <code>llvm::MachineModuleInfo</code> which can then be passed to LLVM’s <code>AsmPrinter</code> pass to generate a relocatable file in memory. The relocatable is then linked to an executable using <a href="https://github.com/ROCm/llvm-project/tree/amd-staging/amd/comgr">AMD CoMGR</a>, which can then be loaded and run inside the ROCm runtime.</p>
</section>
<section id="new-feature-lowering-amdgpu-intrinsics-that-depends-on-hidden-kernel-arguments" class="level2">
<h2 class="anchored" data-anchor-id="new-feature-lowering-amdgpu-intrinsics-that-depends-on-hidden-kernel-arguments">New Feature: Lowering AMDGPU Intrinsics That Depends On Hidden Kernel Arguments</h2>
<p>Let’s say I want to access the <code>blockDim</code> of a kernel inside a hook. On NVIDIA GPUs, accessing this property is very easy; There are dedicated registers the hardware can query to obtain these values; On AMD GPUs, however, there are no dedicated registers for <code>blockDim</code>; Instead, they are either passed as arguments to the SGPRs or as “hidden arguments” in the kernel argument buffer, as stated by the <a href="https://llvm.org/docs/AMDGPUUsage.html#code-object-v3-metadata">AMDGPU backend docs</a>.</p>
<p>This can be easily observed using <a href="https://godbolt.org">Compiler Explorer</a>; The following (very incorrect) HIP code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> square<span class="op">(</span><span class="dt">int</span><span class="op">*</span> array<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tid <span class="op">=</span> blockDim<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>tid <span class="op">&lt;</span> n<span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        array<span class="op">[</span>tid<span class="op">]</span> <span class="op">=</span> array<span class="op">[</span>tid<span class="op">]</span> <span class="op">*</span> array<span class="op">[</span>tid<span class="op">];</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>will result in the following LLVM IR:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ll code-with-copy"><code class="sourceCode llvm"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> <span class="kw">protected</span> amdgpu_kernel <span class="dt">void</span> <span class="fu">@square</span>(int*, int)(ptr addrspace(<span class="dv">1</span>) <span class="kw">nocapture</span> <span class="fu">%array.coerce</span>, <span class="dt">i32</span> <span class="fu">%n</span>) local_unnamed_addr {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">entry:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%0</span> = <span class="kw">tail</span> <span class="kw">call</span> ptr addrspace(<span class="dv">4</span>) <span class="fu">@llvm.amdgcn.implicitarg.ptr</span>()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%1</span> = <span class="kw">getelementptr</span> <span class="kw">inbounds</span> <span class="dt">i16</span>, ptr addrspace(<span class="dv">4</span>) <span class="fu">%0</span>, <span class="dt">i64</span> <span class="dv">6</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%2</span> = <span class="kw">load</span> <span class="dt">i16</span>, ptr addrspace(<span class="dv">4</span>) <span class="fu">%1</span>, <span class="kw">align</span> <span class="dv">4</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%conv.i.i</span> = <span class="kw">zext</span> <span class="dt">i16</span> <span class="fu">%2</span> <span class="kw">to</span> <span class="dt">i32</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%cmp</span> = <span class="kw">icmp</span> <span class="kw">slt</span> <span class="dt">i32</span> <span class="fu">%conv.i.i</span>, <span class="fu">%n</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">br</span> <span class="dt">i1</span> <span class="fu">%cmp</span>, <span class="dt">label</span> <span class="fu">%if.then</span>, <span class="dt">label</span> <span class="fu">%if.end</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="fu">if.then:</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%idxprom</span> = <span class="kw">zext</span> <span class="dt">i16</span> <span class="fu">%2</span> <span class="kw">to</span> <span class="dt">i64</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%arrayidx</span> = <span class="kw">getelementptr</span> <span class="kw">inbounds</span> <span class="dt">i32</span>, ptr addrspace(<span class="dv">1</span>) <span class="fu">%array.coerce</span>, <span class="dt">i64</span> <span class="fu">%idxprom</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%3</span> = <span class="kw">load</span> <span class="dt">i32</span>, ptr addrspace(<span class="dv">1</span>) <span class="fu">%arrayidx</span>, <span class="kw">align</span> <span class="dv">4</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%mul</span> = <span class="kw">mul</span> <span class="kw">nsw</span> <span class="dt">i32</span> <span class="fu">%3</span>, <span class="fu">%3</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">store</span> <span class="dt">i32</span> <span class="fu">%mul</span>, ptr addrspace(<span class="dv">1</span>) <span class="fu">%arrayidx</span>, <span class="kw">align</span> <span class="dv">4</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">br</span> <span class="dt">label</span> <span class="fu">%if.end</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="fu">if.end:</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">void</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="kw">declare</span> <span class="kw">align</span> <span class="dv">4</span> ptr addrspace(<span class="dv">4</span>) <span class="fu">@llvm.amdgcn.implicitarg.ptr</span>() #<span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the first 3 lines, we can see a call to <code>llvm.amdgcn.implicitarg.ptr</code>. This call will result in the pointer to the beginning of the hidden argument to be moved to value <code>%0</code>. Note that if we leave this LLVM intrinsic alone it will have undefined behavior according to the AMDGPU docs. If we need to find a way to replace it with a Luthier intrinsic so that we can lower it correctly ourselves, we should be in the clear.</p>
<p>Another point of note is the constant <code>6</code> offset in the second instruction <code>%1 = getelementptr inbounds i16, ptr addrspace(4) %0, i64 6</code>; We can tell from this that hidden kernel arguments have “fixed” offset for each entry, and I confirmed this by looking at the <a href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/AMDGPU/AMDGPUHSAMetadataStreamer.cpp">AMDGPUMetadataStreamer</a> code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">*</span>Int64Ty <span class="op">=</span> Type<span class="op">::</span>getInt64Ty<span class="op">(</span>Func<span class="op">.</span>getContext<span class="op">());</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">*</span>Int32Ty <span class="op">=</span> Type<span class="op">::</span>getInt32Ty<span class="op">(</span>Func<span class="op">.</span>getContext<span class="op">());</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">*</span>Int16Ty <span class="op">=</span> Type<span class="op">::</span>getInt16Ty<span class="op">(</span>Func<span class="op">.</span>getContext<span class="op">());</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  Offset <span class="op">=</span> alignTo<span class="op">(</span>Offset<span class="op">,</span> ST<span class="op">.</span>getAlignmentForImplicitArgPtr<span class="op">());</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int32Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">4</span><span class="op">),</span> <span class="st">"hidden_block_count_x"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int32Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">4</span><span class="op">),</span> <span class="st">"hidden_block_count_y"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int32Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">4</span><span class="op">),</span> <span class="st">"hidden_block_count_z"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int16Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">2</span><span class="op">),</span> <span class="st">"hidden_group_size_x"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int16Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">2</span><span class="op">),</span> <span class="st">"hidden_group_size_y"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int16Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">2</span><span class="op">),</span> <span class="st">"hidden_group_size_z"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int16Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">2</span><span class="op">),</span> <span class="st">"hidden_remainder_x"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int16Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">2</span><span class="op">),</span> <span class="st">"hidden_remainder_y"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  emitKernelArg<span class="op">(</span>DL<span class="op">,</span> Int16Ty<span class="op">,</span> Align<span class="op">(</span><span class="dv">2</span><span class="op">),</span> <span class="st">"hidden_remainder_z"</span><span class="op">,</span> Offset<span class="op">,</span> Args<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>An offset of 6 <code>i16</code> is 3 <code>i32</code>s, which indeed means we’re trying to access the <code>hidden_group_size_x</code> argument.</p>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>First I had to create a Luthier intrinsic, called <code>luthier::implicitArgPtr</code>. The frontend would look like the following:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\return</span><span class="co"> the address of the implicit argument segment</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>LUTHIER_INTRINSIC_ANNOTATE <span class="dt">uint32_t</span><span class="op">*</span> implicitArgPtr<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span><span class="op">*</span> Out<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  doNotOptimize<span class="op">(</span>Out<span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Out<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This intrinsic, when called, will return a pointer to the beginning of the hidden argument segment.</p>
<p>The next step was to modify the Luthier compiler plugin to replace all uses of <code>llvm.amdgcn.implicitarg.ptr</code> with <code>luthier::implicitArgPtr</code>, which was done by adding the following code snippet right before embedding the modified bitcode:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">*</span>Int32Type <span class="op">=</span> llvm<span class="op">::</span>Type<span class="op">::</span>getInt32Ty<span class="op">(</span>LLVMCtx<span class="op">);</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">*</span>Int32Ptr <span class="op">=</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>      llvm<span class="op">::</span>PointerType<span class="op">::</span>get<span class="op">(</span>Int32Type<span class="op">,</span> llvm<span class="op">::</span>AMDGPUAS<span class="op">::</span>CONSTANT_ADDRESS<span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Replace llvm.amdgcn.workgroup.id intrinsics with the luthier-equivalent</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Remove all kernels that are meant to serve as a host handle</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>F <span class="op">:</span> llvm<span class="op">::</span>make_early_inc_range<span class="op">(</span>ClonedModule<span class="op">-&gt;</span>functions<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;[</span>LLVMName<span class="op">,</span> LuthierName<span class="op">,</span> ReturnType<span class="op">]</span> <span class="op">:</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>         <span class="bu">std::</span>initializer_list<span class="op">&lt;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>             <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*,</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*,</span> llvm<span class="op">::</span>Type <span class="op">*&gt;&gt;{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>             <span class="op">{</span><span class="st">"llvm.amdgcn.workgroup.id.x"</span><span class="op">,</span> <span class="st">"luthier::workgroupIdX"</span><span class="op">,</span> Int32Type<span class="op">},</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>             <span class="op">{</span><span class="st">"llvm.amdgcn.workgroup.idx.y"</span><span class="op">,</span> <span class="st">"luthier::workgroupIdY"</span><span class="op">,</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>              Int32Type<span class="op">},</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>             <span class="op">{</span><span class="st">"llvm.amdgcn.workgroup.idx.z"</span><span class="op">,</span> <span class="st">"luthier::workgroupIdZ"</span><span class="op">,</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>              Int32Type<span class="op">},</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>             <span class="op">{</span><span class="st">"llvm.amdgcn.implicitarg.ptr"</span><span class="op">,</span> <span class="st">"luthier::implicitArgPtr"</span><span class="op">,</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>              Int32Ptr<span class="op">}})</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>F<span class="op">.</span>getName<span class="op">().</span>starts_with<span class="op">(</span>LLVMName<span class="op">))</span> <span class="op">{</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">*</span>User <span class="op">:</span> llvm<span class="op">::</span>make_early_inc_range<span class="op">(</span>F<span class="op">.</span>users<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>          <span class="kw">auto</span> <span class="op">*</span>CallInst <span class="op">=</span> llvm<span class="op">::</span>dyn_cast<span class="op">&lt;</span>llvm<span class="op">::</span>CallInst<span class="op">&gt;(</span>User<span class="op">);</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>          llvm<span class="op">::</span>IRBuilder<span class="op">&lt;&gt;</span> Builder<span class="op">(</span>CallInst<span class="op">);</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>          <span class="kw">auto</span> <span class="op">*</span>LuthierIntrinsicCall <span class="op">=</span> insertCallToIntrinsic<span class="op">(</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>              <span class="op">*</span>ClonedModule<span class="op">,</span> Builder<span class="op">,</span> LuthierName<span class="op">,</span> <span class="op">*</span>ReturnType<span class="op">);</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>          CallInst<span class="op">-&gt;</span>replaceAllUsesWith<span class="op">(</span>LuthierIntrinsicCall<span class="op">);</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>          CallInst<span class="op">-&gt;</span>eraseFromParent<span class="op">();</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        F<span class="op">.</span>dropAllReferences<span class="op">();</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        F<span class="op">.</span>eraseFromParent<span class="op">();</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(Note that I plan to do a similar thing for other special intrinsics).</p>
<p>Now that we’ve generated valid instrumentation IR, it was time to implement a way to lower this intrinsic. To do that, I need to add an additional feature to the Luthier intrinsic lowering mechanism: Accessing kernel arguments, which meant the MIR lowering callbacks had to be modified with an additional lambda:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> luthier <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\brief</span><span class="co"> a set of kernel arguments Luthier's intrinsic lowering mechanism</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">/// can ensure access to</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\details</span><span class="co"> these values are only available to the kernel as "arguments"</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">/// as they come either preloaded in S/VGPRs or they are passed as "hidden"</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">/// arguments in the kernel argument buffer. As these values (or the way to</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">/// access them) are stored in GPRs they can be overwritten the moment they</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">/// are unused by the instrumented app. To ensure access to these values</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">/// in instrumentation routines, Luthier must emit a prologue on top of the</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">/// kernel's original prologue to save these values in an unused register,</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">/// or spill them to the top of the instrumentation stack's buffer to be</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">/// loaded when necessary</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> KernelArgumentType <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Wavefront's private segment buffer</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  WAVEFRONT_PRIVATE_SEGMENT_BUFFER <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Enum marking the beginning of kernel arguments always passed on SGPRs</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  ALWAYS_IN_SGPR_BEGIN <span class="op">=</span> WAVEFRONT_PRIVATE_SEGMENT_BUFFER<span class="op">,</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 64-bit address of the kernel's argument buffer</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  KERNARG_SEGMENT_PTR <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 32-bit offset from the beginning of the kernel's argument buffer where</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// the kernel's hidden arguments starts</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  HIDDEN_KERNARG_OFFSET <span class="op">=</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 32-bit offset from the beginning of the kernel's argument buffer where</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// the instrumentation-passed (i.e. user) argument buffer starts</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>  USER_KERNARG_OFFSET <span class="op">=</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 64-bit Dispatch ID of the kernel</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>  DISPATCH_ID <span class="op">=</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 64-bit flat scratch base address of the wavefront</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>  FLAT_SCRATCH <span class="op">=</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 32-bit private segment wave offset</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>  PRIVATE_SEGMENT_WAVE_BYTE_OFFSET <span class="op">=</span> <span class="dv">6</span><span class="op">,</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Enum marking the end of kernel arguments always passed on SGPRs</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>  ALWAYS_IN_SGPR_END <span class="op">=</span> PRIVATE_SEGMENT_WAVE_BYTE_OFFSET<span class="op">,</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 64-bit address of the dispatch packet of the kernel being executed</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>  DISPATCH_PTR <span class="op">=</span> <span class="dv">7</span><span class="op">,</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Enum marking the beginning of kernel arguments that can either be passed</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// on SGPRs or hidden kernel arguments</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>  EITHER_IN_SGPR_OR_HIDDEN_BEGIN <span class="op">=</span> DISPATCH_PTR<span class="op">,</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// 64-bit address of the HSA queue used to launch the kernel</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>  QUEUE_PTR <span class="op">=</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Size of a work-item's private segment</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>  WORK_ITEM_PRIVATE_SEGMENT_SIZE <span class="op">=</span> <span class="dv">9</span><span class="op">,</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Enum marking the end of kernel arguments that are either passed on the</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// SGPRs or hidden kernel arguments</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>  EITHER_IN_SGPR_OR_HIDDEN_END <span class="op">=</span> WORK_ITEM_PRIVATE_SEGMENT_SIZE<span class="op">,</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Dispatch workgroup work-item count for the x dimension</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>  BLOCK_COUNT_X <span class="op">=</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Enum marking the beginning of hidden-only kernel arguments</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>  HIDDEN_BEGIN <span class="op">=</span> BLOCK_COUNT_X<span class="op">,</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Dispatch workgroup work-item count for the y dimension</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>  BLOCK_COUNT_Y <span class="op">=</span> <span class="dv">11</span><span class="op">,</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Dispatch workgroup work-item count for the z dimension</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>  BLOCK_COUNT_Z <span class="op">=</span> <span class="dv">12</span><span class="op">,</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>  GROUP_SIZE_X <span class="op">=</span> <span class="dv">13</span><span class="op">,</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>  GROUP_SIZE_Y <span class="op">=</span> <span class="dv">14</span><span class="op">,</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>  GROUP_SIZE_Z <span class="op">=</span> <span class="dv">15</span><span class="op">,</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>  REMAINDER_X <span class="op">=</span> <span class="dv">16</span><span class="op">,</span></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>  REMAINDER_Y <span class="op">=</span> <span class="dv">17</span><span class="op">,</span></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>  REMAINDER_Z <span class="op">=</span> <span class="dv">18</span><span class="op">,</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>  GLOBAL_OFFSET_X <span class="op">=</span> <span class="dv">19</span><span class="op">,</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>  GLOBAL_OFFSET_Y <span class="op">=</span> <span class="dv">20</span><span class="op">,</span></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>  GLOBAL_OFFSET_Z <span class="op">=</span> <span class="dv">21</span><span class="op">,</span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>  PRINT_BUFFER <span class="op">=</span> <span class="dv">22</span><span class="op">,</span></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>  HOSTCALL_BUFFER <span class="op">=</span> <span class="dv">23</span><span class="op">,</span></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>  DEFAULT_QUEUE <span class="op">=</span> <span class="dv">24</span><span class="op">,</span></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>  COMPLETION_ACTION <span class="op">=</span> <span class="dv">25</span><span class="op">,</span></span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>  MULTIGRID_SYNC <span class="op">=</span> <span class="dv">26</span><span class="op">,</span></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>  GRID_DIMS <span class="op">=</span> <span class="dv">27</span><span class="op">,</span></span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>  HEAP_V1 <span class="op">=</span> <span class="dv">28</span><span class="op">,</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>  DYNAMIC_LDS_SIZE <span class="op">=</span> <span class="dv">29</span><span class="op">,</span></span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>  PRIVATE_BASE <span class="op">=</span> <span class="dv">30</span><span class="op">,</span></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>  SHARED_BASE <span class="op">=</span> <span class="dv">31</span><span class="op">,</span></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>  HIDDEN_END <span class="op">=</span> SHARED_BASE<span class="op">,</span></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>  WORK_ITEM_X <span class="op">=</span> <span class="dv">32</span><span class="op">,</span></span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>  WORK_ITEM_Y <span class="op">=</span> <span class="dv">33</span><span class="op">,</span></span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>  WORK_ITEM_Z <span class="op">=</span> <span class="dv">34</span></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\brief</span><span class="co"> describes a function type used for each intrinsic to generate</span></span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="kw">&lt;tt&gt;</span><span class="co">llvm::MachineInstr</span><span class="kw">&lt;/tt&gt;</span><span class="co">s in place of its IR calls.</span></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a><span class="co">/// The MIR processor takes in the</span></span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\c</span><span class="co"> </span><span class="cv">IntrinsicIRLoweringInfo</span><span class="co"> generated by its </span><span class="an">\c</span><span class="co"> </span><span class="cv">IntrinsicIRProcessorFunc</span><span class="co"> as</span></span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a><span class="co">/// well as the lowered registers and their inline assembly flags for</span></span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a><span class="co">/// its used/defined values. A lambda which will create an</span></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\c</span><span class="co"> </span><span class="cv">llvm::MachineInstr</span><span class="co"> at the place of emission given an instruction opcode</span></span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a><span class="co">/// is also passed to this function</span></span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>Error<span class="op">(</span></span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> IntrinsicIRLoweringInfo <span class="op">&amp;,</span></span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>ArrayRef<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span>llvm<span class="op">::</span>InlineAsm<span class="op">::</span>Flag<span class="op">,</span> llvm<span class="op">::</span>Register<span class="op">&gt;&gt;,</span></span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>MachineInstrBuilder<span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> <span class="op">&amp;,</span></span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>Register<span class="op">(</span><span class="at">const</span> llvm<span class="op">::</span>TargetRegisterClass <span class="op">*)&gt;</span> <span class="op">&amp;,</span></span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>Register<span class="op">(</span>KernelArgumentType<span class="op">)&gt;</span> <span class="op">&amp;,</span></span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> llvm<span class="op">::</span>MachineFunction <span class="op">&amp;,</span></span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>Register<span class="op">(</span>llvm<span class="op">::</span>MCRegister<span class="op">)&gt;</span> <span class="op">&amp;,</span></span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>DenseMap<span class="op">&lt;</span>llvm<span class="op">::</span>MCRegister<span class="op">,</span> llvm<span class="op">::</span>Register<span class="op">&gt;</span> <span class="op">&amp;)&gt;</span></span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true" tabindex="-1"></a>    IntrinsicMIRProcessorFunc<span class="op">;</span></span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">\brief</span><span class="co"> Used internally by </span><span class="an">\c</span><span class="co"> </span><span class="cv">luthier::CodeGenerator</span><span class="co"> to keep track of</span></span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true" tabindex="-1"></a><span class="co">/// registered intrinsics and how to process them</span></span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> IntrinsicProcessor <span class="op">{</span></span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true" tabindex="-1"></a>  IntrinsicIRProcessorFunc IRProcessor<span class="op">{};</span></span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true" tabindex="-1"></a>  IntrinsicMIRProcessorFunc MIRProcessor<span class="op">{};</span></span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The new argument to the <code>IntrinsicMIRProcessorFunc</code> is a function which will return a virtual register that contains the value of that “kernel argument”. That function is implemented inside <code>IntrinsicMIRLoweringPass</code> as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> SVAAccessorBuilder <span class="op">=</span> <span class="op">[&amp;](</span>KernelArgumentType KA<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">auto</span> LaneId <span class="op">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>              stateValueArray<span class="op">::</span>getKernelArgumentLaneIdStoreSlotBeginForWave64<span class="op">(</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                  KA<span class="op">);</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>          LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span>LaneId<span class="op">.</span>takeError<span class="op">());</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">auto</span> ArgSize <span class="op">=</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>              stateValueArray<span class="op">::</span>getKernelArgumentStoreSlotSizeForWave64<span class="op">(</span>KA<span class="op">);</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>          LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span>ArgSize<span class="op">.</span>takeError<span class="op">());</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>          llvm<span class="op">::</span>SmallVector<span class="op">&lt;</span>llvm<span class="op">::</span>Register<span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> Out<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">short</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="op">*</span>ArgSize<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            Out<span class="op">.</span>push_back<span class="op">(</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                MRI<span class="op">.</span>createVirtualRegister<span class="op">(&amp;</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>SGPR_32RegClass<span class="op">));</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            llvm<span class="op">::</span>BuildMI<span class="op">(</span>MBB<span class="op">,</span> MI<span class="op">,</span> llvm<span class="op">::</span>MIMetadata<span class="op">(</span>MI<span class="op">),</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                          TII<span class="op">-&gt;</span>get<span class="op">(</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>V_READLANE_B32<span class="op">),</span> Out<span class="op">.</span>back<span class="op">())</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>addReg<span class="op">(</span>SVAVGPR<span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>addImm<span class="op">(*</span>LaneId <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>          <span class="co">// Add the requested kernarg</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>          <span class="kw">auto</span> TargetMF <span class="op">=</span> TargetMI<span class="op">.</span>getParent<span class="op">()-&gt;</span>getParent<span class="op">();</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>TargetMF<span class="op">-&gt;</span>getFunction<span class="op">().</span>getCallingConv<span class="op">()</span> <span class="op">==</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>              llvm<span class="op">::</span>CallingConv<span class="op">::</span>AMDGPU_KERNEL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            PreambleDescriptor<span class="op">.</span>Kernels<span class="op">[</span>TargetMF<span class="op">]</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>RequestedKernelArguments<span class="op">.</span>insert<span class="op">(</span>KA<span class="op">);</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            PreambleDescriptor<span class="op">.</span>DeviceFunctions<span class="op">[</span>TargetMF<span class="op">]</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>RequestedKernelArguments<span class="op">.</span>insert<span class="op">(</span>KA<span class="op">);</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>          <span class="co">// Emit a reg sequence if the arg size was greater than 1</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(*</span>ArgSize <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// First create a reg sequence MI</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> Builder <span class="op">=</span> MIBuilder<span class="op">(</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>REG_SEQUENCE<span class="op">);</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> MergedReg <span class="op">=</span> MRI<span class="op">.</span>createVirtualRegister<span class="op">(</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>                llvm<span class="op">::</span>SIRegisterInfo<span class="op">::</span>getSGPRClassForBitWidth<span class="op">(*</span>ArgSize <span class="op">*</span> <span class="dv">32</span><span class="op">));</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>            Builder<span class="op">.</span>addReg<span class="op">(</span>MergedReg<span class="op">,</span> llvm<span class="op">::</span>RegState<span class="op">::</span>Define<span class="op">);</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Split the src reg into 32-bit regs, and merge them in the</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;[</span>SubIdx<span class="op">,</span> Reg<span class="op">]</span> <span class="op">:</span> llvm<span class="op">::</span>enumerate<span class="op">(</span>Out<span class="op">))</span> <span class="op">{</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>              Builder<span class="op">.</span>addReg<span class="op">(</span>Reg<span class="op">).</span>addImm<span class="op">(</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>                  llvm<span class="op">::</span>SIRegisterInfo<span class="op">::</span>getSubRegFromChannel<span class="op">(</span>SubIdx<span class="op">));</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> MergedReg<span class="op">;</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Out<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each kernel argument will be stored in fixed lane(s) of the SVA. Kernel argument address is saved in lanes 15 and 16, and the offset for the hidden kernel arg is located in lane 17.</p>
<p>With the MIR lowering callback now modified, we can implement a lowering mechanism for the <code>luthier::implicitArgPtr</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> luthier <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>llvm<span class="op">::</span>Expected<span class="op">&lt;</span>IntrinsicIRLoweringInfo<span class="op">&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>implicitArgPtrIRProcessor<span class="op">(</span><span class="at">const</span> llvm<span class="op">::</span>Function <span class="op">&amp;</span>Intrinsic<span class="op">,</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                          <span class="at">const</span> llvm<span class="op">::</span>CallInst <span class="op">&amp;</span>User<span class="op">,</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                          <span class="at">const</span> llvm<span class="op">::</span>GCNTargetMachine <span class="op">&amp;</span>TM<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The user must not have any operands</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  LUTHIER_RETURN_ON_ERROR<span class="op">(</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>      LUTHIER_ERROR_CHECK<span class="op">(</span>User<span class="op">.</span>arg_size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>                          <span class="st">"Expected no operands to be passed to the "</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>                          <span class="st">"luthier::implicitArgPtr intrinsic '</span><span class="sc">{0}</span><span class="st">', got </span><span class="sc">{1}</span><span class="st">."</span><span class="op">,</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                          User<span class="op">,</span> User<span class="op">.</span>arg_size<span class="op">()));</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  luthier<span class="op">::</span>IntrinsicIRLoweringInfo Out<span class="op">;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The kernarg hidden address will be returned in an SGPR</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  Out<span class="op">.</span>setReturnValueInfo<span class="op">(&amp;</span>User<span class="op">,</span> <span class="st">"s"</span><span class="op">);</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Out<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>llvm<span class="op">::</span>Error implicitArgPtrMIRProcessor<span class="op">(</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> IntrinsicIRLoweringInfo <span class="op">&amp;</span>IRLoweringInfo<span class="op">,</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>ArrayRef<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span>llvm<span class="op">::</span>InlineAsm<span class="op">::</span>Flag<span class="op">,</span> llvm<span class="op">::</span>Register<span class="op">&gt;&gt;</span> Args<span class="op">,</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>MachineInstrBuilder<span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> <span class="op">&amp;</span>MIBuilder<span class="op">,</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>Register<span class="op">(</span><span class="at">const</span> llvm<span class="op">::</span>TargetRegisterClass <span class="op">*)&gt;</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;</span>VirtRegBuilder<span class="op">,</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>Register<span class="op">(</span>KernelArgumentType<span class="op">)&gt;</span> <span class="op">&amp;</span>KernArgAccessor<span class="op">,</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> llvm<span class="op">::</span>MachineFunction <span class="op">&amp;</span>MF<span class="op">,</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>function<span class="op">&lt;</span>llvm<span class="op">::</span>Register<span class="op">(</span>llvm<span class="op">::</span>MCRegister<span class="op">)&gt;</span> <span class="op">&amp;</span>PhysRegAccessor<span class="op">,</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    llvm<span class="op">::</span>DenseMap<span class="op">&lt;</span>llvm<span class="op">::</span>MCRegister<span class="op">,</span> llvm<span class="op">::</span>Register<span class="op">&gt;</span> <span class="op">&amp;</span>PhysRegsToBeOverwritten<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">// There should be only a single virtual register involved in the operation</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>  LUTHIER_RETURN_ON_ERROR<span class="op">(</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>      LUTHIER_ERROR_CHECK<span class="op">(</span>Args<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>                          <span class="st">"Number of virtual register arguments "</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>                          <span class="st">"involved in the MIR lowering stage of "</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>                          <span class="st">"luthier::implicitArgPtr is </span><span class="sc">{0}</span><span class="st"> instead of 1."</span><span class="op">,</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>                          Args<span class="op">.</span>size<span class="op">()));</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>  LUTHIER_RETURN_ON_ERROR<span class="op">(</span>LUTHIER_ERROR_CHECK<span class="op">(</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>      Args<span class="op">[</span><span class="dv">0</span><span class="op">].</span>first<span class="op">.</span>isRegDefKind<span class="op">(),</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>      <span class="st">"The register argument of luthier::implicitArgPtr is not a definition."</span><span class="op">));</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>Register Output <span class="op">=</span> Args<span class="op">[</span><span class="dv">0</span><span class="op">].</span>second<span class="op">;</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the kernel argument</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>Register KernArgSGPR <span class="op">=</span> KernArgAccessor<span class="op">(</span>KERNARG_SEGMENT_PTR<span class="op">);</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the offset of the hidden arg</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>Register HiddenOffsetSGPR <span class="op">=</span> KernArgAccessor<span class="op">(</span>HIDDEN_KERNARG_OFFSET<span class="op">);</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The lower part of the hidden argument address</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>Register FirstAddSGPR <span class="op">=</span> VirtRegBuilder<span class="op">(&amp;</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>SGPR_32RegClass<span class="op">);</span></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The upper part of the hidden argument address</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>  llvm<span class="op">::</span>Register SecondAddSGPR <span class="op">=</span> VirtRegBuilder<span class="op">(&amp;</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>SGPR_32RegClass<span class="op">);</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the hidden argument offset to the kernel argument address's</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lower register</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>  MIBuilder<span class="op">(</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>S_ADD_U32<span class="op">)</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>FirstAddSGPR<span class="op">,</span> llvm<span class="op">::</span>RegState<span class="op">::</span>Define<span class="op">)</span></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>KernArgSGPR<span class="op">,</span> llvm<span class="op">::</span>RegState<span class="op">::</span>Kill<span class="op">,</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>              llvm<span class="op">::</span>SIRegisterInfo<span class="op">::</span>getSubRegFromChannel<span class="op">(</span><span class="dv">0</span><span class="op">))</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>HiddenOffsetSGPR<span class="op">,</span> llvm<span class="op">::</span>RegState<span class="op">::</span>Kill<span class="op">);</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add the carry to the upper register fo the kernel argument address</span></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>  MIBuilder<span class="op">(</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>S_ADDC_U32<span class="op">)</span></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>SecondAddSGPR<span class="op">,</span> llvm<span class="op">::</span>RegState<span class="op">::</span>Define<span class="op">)</span></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>KernArgSGPR<span class="op">,</span> llvm<span class="op">::</span>RegState<span class="op">::</span>Kill<span class="op">,</span></span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a>              llvm<span class="op">::</span>SIRegisterInfo<span class="op">::</span>getSubRegFromChannel<span class="op">(</span><span class="dv">1</span><span class="op">))</span></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addImm<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Do a reg sequence copy to the output to return it</span></span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a>  <span class="op">(</span><span class="dt">void</span><span class="op">)</span>MIBuilder<span class="op">(</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>REG_SEQUENCE<span class="op">)</span></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>Output<span class="op">,</span> llvm<span class="op">::</span>RegState<span class="op">::</span>Define<span class="op">)</span></span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>SecondAddSGPR<span class="op">)</span></span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addImm<span class="op">(</span>llvm<span class="op">::</span>SIRegisterInfo<span class="op">::</span>getSubRegFromChannel<span class="op">(</span><span class="dv">1</span><span class="op">))</span></span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addReg<span class="op">(</span>FirstAddSGPR<span class="op">)</span></span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>addImm<span class="op">(</span>llvm<span class="op">::</span>SIRegisterInfo<span class="op">::</span>getSubRegFromChannel<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> llvm<span class="op">::</span>Error<span class="op">::</span>success<span class="op">();</span></span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// namespace luthier</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we have to add support to the <code>PrePostAmbleEmitter.cpp</code>, so that whenever we need access to the hidden kernel argument offset, we extract it from the metadata and hardcode it into the kernel pre-amble. The kernel argument buffer address is different as it is an SGPR argument:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If access to kernarg buffer was requested, enable it</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>SVAInfo<span class="op">.</span>RequestedKernelArguments<span class="op">.</span>contains<span class="op">(</span>KERNARG_SEGMENT_PTR<span class="op">))</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>          enableKernArg<span class="op">(</span>MFI<span class="op">,</span> TRI<span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Omitted code for handling scratch</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Emit code to store the rest of the requested SGPR kernel arguments</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;[</span>KernArg<span class="op">,</span> PreloadValue<span class="op">]</span> <span class="op">:</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>             <span class="op">{</span><span class="bu">std::</span>pair<span class="op">{</span>KERNARG_SEGMENT_PTR<span class="op">,</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                        llvm<span class="op">::</span>AMDGPUFunctionArgInfo<span class="op">::</span>KERNARG_SEGMENT_PTR<span class="op">},</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>              <span class="op">{</span>DISPATCH_ID<span class="op">,</span> llvm<span class="op">::</span>AMDGPUFunctionArgInfo<span class="op">::</span>DISPATCH_ID<span class="op">},</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>              <span class="op">{</span>DISPATCH_PTR<span class="op">,</span> llvm<span class="op">::</span>AMDGPUFunctionArgInfo<span class="op">::</span>DISPATCH_PTR<span class="op">},</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>              <span class="op">{</span>QUEUE_PTR<span class="op">,</span> llvm<span class="op">::</span>AMDGPUFunctionArgInfo<span class="op">::</span>QUEUE_PTR<span class="op">}})</span> <span class="op">{</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>SVAInfo<span class="op">.</span>RequestedKernelArguments<span class="op">.</span>contains<span class="op">(</span>KernArg<span class="op">))</span> <span class="op">{</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> StoreSlotBegin <span class="op">=</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>                stateValueArray<span class="op">::</span>getKernelArgumentLaneIdStoreSlotBeginForWave64<span class="op">(</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>                    KernArg<span class="op">);</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> Err <span class="op">=</span> StoreSlotBegin<span class="op">.</span>takeError<span class="op">())</span> <span class="op">{</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>              TargetModule<span class="op">.</span>getContext<span class="op">().</span>emitError<span class="op">(</span>toString<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>Err<span class="op">)));</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>              <span class="cf">return</span> llvm<span class="op">::</span>PreservedAnalyses<span class="op">::</span>all<span class="op">();</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> StoreSlotSize <span class="op">=</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>                stateValueArray<span class="op">::</span>getKernelArgumentStoreSlotSizeForWave64<span class="op">(</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>                    KernArg<span class="op">);</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> Err <span class="op">=</span> StoreSlotSize<span class="op">.</span>takeError<span class="op">())</span> <span class="op">{</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>              TargetModule<span class="op">.</span>getContext<span class="op">().</span>emitError<span class="op">(</span>toString<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>Err<span class="op">)));</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>              <span class="cf">return</span> llvm<span class="op">::</span>PreservedAnalyses<span class="op">::</span>all<span class="op">();</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> Err <span class="op">=</span> emitCodeToStoreSGPRKernelArg<span class="op">(</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>                    <span class="op">*</span>EntryInstr<span class="op">,</span> getArgReg<span class="op">(*</span>MF<span class="op">,</span> PreloadValue<span class="op">),</span> SVSStorageReg<span class="op">,</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>                    <span class="op">*</span>StoreSlotBegin<span class="op">,</span> <span class="op">*</span>StoreSlotSize<span class="op">,</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>                    OriginalSGPRArgLocs<span class="op">.</span>contains<span class="op">(</span>PreloadValue<span class="op">)))</span> <span class="op">{</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>              TargetModule<span class="op">.</span>getContext<span class="op">().</span>emitError<span class="op">(</span>toString<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>Err<span class="op">)));</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>              <span class="cf">return</span> llvm<span class="op">::</span>PreservedAnalyses<span class="op">::</span>all<span class="op">();</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="co">// Add code for storring the hidden kernarg offset</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>SVAInfo<span class="op">.</span>RequestedKernelArguments<span class="op">.</span>contains<span class="op">(</span>HIDDEN_KERNARG_OFFSET<span class="op">))</span> <span class="op">{</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>          llvm<span class="op">::</span>outs<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"emitting code to store the hidden arg offset.</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>          <span class="kw">auto</span> <span class="op">&amp;</span>KernArgs <span class="op">=</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>              llvm<span class="op">::</span>dyn_cast<span class="op">&lt;</span>hsa<span class="op">::</span>LoadedCodeObjectKernel<span class="op">&gt;(</span>FuncSymbol<span class="op">)</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>                  <span class="op">-&gt;</span>getKernelMetadata<span class="op">()</span></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>                  <span class="op">.</span>Args<span class="op">;</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>          LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span>LUTHIER_ERROR_CHECK<span class="op">(</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>              KernArgs<span class="op">.</span>has_value<span class="op">(),</span> <span class="st">"Attempted to access the hidden arguments "</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">"of a kernel without any arguments."</span><span class="op">));</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>          <span class="dt">uint32_t</span> HiddenOffset <span class="op">=</span> <span class="op">[&amp;]()</span> <span class="op">{</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;</span>Arg <span class="op">:</span> <span class="op">*</span>KernArgs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">(</span>Arg<span class="op">.</span>ValueKind <span class="op">&gt;=</span> hsa<span class="op">::</span>md<span class="op">::</span>ValueKind<span class="op">::</span>HiddenArgKindBegin <span class="op">&amp;&amp;</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>                  Arg<span class="op">.</span>ValueKind <span class="op">&lt;=</span> hsa<span class="op">::</span>md<span class="op">::</span>ValueKind<span class="op">::</span>HiddenArgKindEnd<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> Arg<span class="op">.</span>Offset<span class="op">;</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>              <span class="op">}</span></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dt">uint32_t</span><span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>          <span class="op">}();</span></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>          <span class="kw">auto</span> StoreLane <span class="op">=</span></span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>              stateValueArray<span class="op">::</span>getKernelArgumentLaneIdStoreSlotBeginForWave64<span class="op">(</span></span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>                  HIDDEN_KERNARG_OFFSET<span class="op">);</span></span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a>          LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span>StoreLane<span class="op">.</span>takeError<span class="op">());</span></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a>          llvm<span class="op">::</span>BuildMI<span class="op">(*</span>EntryInstr<span class="op">-&gt;</span>getParent<span class="op">(),</span> EntryInstr<span class="op">,</span> llvm<span class="op">::</span>DebugLoc<span class="op">(),</span></span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a>                        TII<span class="op">-&gt;</span>get<span class="op">(</span>llvm<span class="op">::</span>AMDGPU<span class="op">::</span>V_WRITELANE_B32<span class="op">),</span> SVSStorageReg<span class="op">)</span></span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span>addImm<span class="op">(</span>HiddenOffset<span class="op">)</span></span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span>addImm<span class="op">(*</span>StoreLane<span class="op">)</span></span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span>addReg<span class="op">(</span>SVSStorageReg<span class="op">);</span></span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a>          EntryInstr<span class="op">-&gt;</span>getMF<span class="op">()-&gt;</span>print<span class="op">(</span>llvm<span class="op">::</span>outs<span class="op">());</span></span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That’s it!</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>For validating the implementation, I wrote a tool which instrumented the last instruction of the first basic block to copy over the <code>gridDim</code> into a managed variables as follows</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>MARK_LUTHIER_DEVICE_MODULE</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">/// Where we will write the grid dim</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ex">__attribute__((managed))</span> dim3 GridDim<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">/// Copy over the grid dim and block dim</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>LUTHIER_HOOK_ANNOTATE accessKernelArg<span class="op">()</span> <span class="op">{</span> GridDim <span class="op">=</span> gridDim<span class="op">;}</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>LUTHIER_EXPORT_HOOK_HANDLE<span class="op">(</span>accessKernelArg<span class="op">);</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="co">/// Instruments the last instruction of the first basic block</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> llvm<span class="op">::</span>Error instrumentationLoop<span class="op">(</span>InstrumentationTask <span class="op">&amp;</span>IT<span class="op">,</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>                                       LiftedRepresentation <span class="op">&amp;</span>LR<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;[</span>_<span class="op">,</span> MF<span class="op">]</span> <span class="op">:</span> LR<span class="op">.</span>functions<span class="op">())</span> <span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    LUTHIER_RETURN_ON_ERROR<span class="op">(</span>IT<span class="op">.</span>insertHookBefore<span class="op">(</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        MF<span class="op">-&gt;</span>begin<span class="op">()-&gt;</span>back<span class="op">(),</span> LUTHIER_GET_HOOK_HANDLE<span class="op">(</span>accessKernelArg<span class="op">)));</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> llvm<span class="op">::</span>Error<span class="op">::</span>success<span class="op">();</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">void</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>instrumentAllFunctionsOfLR<span class="op">(</span><span class="at">const</span> hsa<span class="op">::</span>LoadedCodeObjectKernel <span class="op">&amp;</span>Kernel<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> LR <span class="op">=</span> lift<span class="op">(</span>Kernel<span class="op">);</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>  LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span>LR<span class="op">.</span>takeError<span class="op">());</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>  LUTHIER_REPORT_FATAL_ON_ERROR<span class="op">(</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>      instrumentAndLoad<span class="op">(</span>Kernel<span class="op">,</span> <span class="op">*</span>LR<span class="op">,</span> instrumentationLoop<span class="op">,</span> <span class="st">"kernarg_access"</span><span class="op">));</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On three separate benchmarks in the <a href="https://github.com/zjin-lcf/HeCBench">HecBench</a> this tool will return the correct <code>gridDim</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co"># affine-hip</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="va">LD_PRELOAD</span><span class="op">=</span>./examples/KernelArgumentIntrinsic/libKernelArgumentIntrinsic.so <span class="ex">./main</span> data/CT-MONO2-16-brain.raw result.raw 1000000</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Kernel</span> 15529 <span class="at">-</span> affine<span class="er">(</span><span class="ex">unsigned</span> short const<span class="pp">*</span>, unsigned short<span class="pp">*</span><span class="kw">)</span><span class="bu">:</span> Total Grid Size Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">512,</span> 512, 1<span class="kw">)</span> <span class="ex">Workgroup</span> Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">16,</span> 16, 1<span class="kw">)</span> <span class="bu">:</span> GridDim <span class="er">(</span><span class="ex">HIP</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">32,</span> 32, 1<span class="kw">)</span><span class="bu">.</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co"># asta-hip</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="va">LD_PRELOAD</span><span class="op">=</span>./examples/KernelArgumentIntrinsic/libKernelArgumentIntrinsic.so <span class="ex">./main</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="ex">Kernel</span> 35 <span class="at">-</span> PTTWAC_soa_asta<span class="er">(</span><span class="ex">int,</span> int, int, float<span class="pp">*</span>, int<span class="pp">*</span>, int<span class="pp">*</span><span class="kw">)</span><span class="bu">:</span> Total Grid Size Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">1024,</span> 1, 1<span class="kw">)</span> <span class="ex">Workgroup</span> Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">64,</span> 1, 1<span class="kw">)</span> <span class="bu">:</span> GridDim <span class="er">(</span><span class="ex">HIP</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">16,</span> 1, 1<span class="kw">)</span><span class="bu">.</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co"># complex-hip</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="va">LD_PRELOAD</span><span class="op">=</span>./examples/KernelArgumentIntrinsic/libKernelArgumentIntrinsic.so <span class="ex">./main</span> 10000000 1000</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="ex">Kernel</span> 0 <span class="at">-</span> complex_float<span class="er">(</span><span class="ex">char*,</span> int<span class="kw">)</span><span class="bu">:</span> Total Grid Size Dims: <span class="er">(</span><span class="ex">10000128,</span> 1, 1<span class="kw">)</span> <span class="ex">Workgroup</span> Dims: <span class="er">(</span><span class="ex">256,</span> 1, 1<span class="kw">)</span> <span class="ex">Kernel</span> block count: <span class="er">(</span><span class="ex">39063,</span> 1, 1<span class="kw">)</span><span class="bu">.</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="ex">Kernel</span> 3001 <span class="at">-</span> complex_double<span class="er">(</span><span class="ex">char*,</span> int<span class="kw">)</span><span class="bu">:</span> Total Grid Size Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">10000128,</span> 1, 1<span class="kw">)</span> <span class="ex">Workgroup</span> Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">256,</span> 1, 1<span class="kw">)</span> <span class="bu">:</span> GridDim <span class="er">(</span><span class="ex">HIP</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">39063,</span> 1, 1<span class="kw">)</span><span class="bu">.</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="ex">Kernel</span> 4001 <span class="at">-</span> ref_complex_double<span class="er">(</span><span class="ex">char*,</span> int<span class="kw">)</span><span class="bu">:</span> Total Grid Size Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">10000128,</span> 1, 1<span class="kw">)</span> <span class="ex">Workgroup</span> Dims <span class="er">(</span><span class="ex">HSA</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">256,</span> 1, 1<span class="kw">)</span> <span class="bu">:</span> GridDim <span class="er">(</span><span class="ex">HIP</span><span class="kw">)</span><span class="bu">:</span> <span class="er">(</span><span class="ex">39063,</span> 1, 1<span class="kw">)</span><span class="bu">.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Seems like it works! Though more testing is needed to handle more corner cases, I’m able to extract the correct grid dim and block dim of the launched kernel from inside the kernel itself, which is enough to prove that this was a success.</p>
</section>
<section id="conclusion-and-future-work" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-and-future-work">Conclusion and Future Work</h2>
<p>Though the code is successfully lowered to correct code, there is still work that needs to be done: 1. If a kernel doesn’t require access to hidden arguments, it might not be setup by the ROCCLR low-level runtime; If this is indeed the case, Luthier instead needs to setup the kernel arguments. This will be extra important for things like host call buffers, which don’t get passed to kernels by default. 2. I setup the hidden kernel argument offset by writing an immediate value to the SVA lane; For kernels with a lot of explicit arguments this offset must be written to an SGPR first before the <code>WRITELANE</code> instruction. 3. Since hooks potentially can be called many many times inside a kernel, reading from the kernel argument memory many times is not efficient. Instead of replacing the <code>implicitarg</code> LLVM intrinsic, we need to look at the offsets that they are loading from, and use that to detect the exact kernel arguments they are accessing. This way, we can only do this once in the pre-amble and store it in the SVA, so that we can access it later. 4. I need to test more hidden kernel arguments.</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/normrubin\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../blogs/matin/2024-11-01-HW5.html" class="pagination-link" aria-label="Homework 5">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Homework 5</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../blogs/michael/09-20-2024-HW1-MichaelMaurer.html" class="pagination-link" aria-label="EECE7309 Homework 1 -- Trying Out Bril">
        <span class="nav-page-text">EECE7309 Homework 1 – Trying Out Bril</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><a href="https://normrubin.github.io/">EECS 7398 website</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions"><ul><li><a href="https://github.com/normrubin/normrubin.github.io/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This page is built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>