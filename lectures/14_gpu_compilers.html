<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>GPU Compilers – EECE7398 Fall 2024</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta property="og:title" content="GPU Compilers – EECE7398 Fall 2024">
<meta property="og:description" content="Homepage EECS7398 - Special Topic: Compilers, Fall 2024.">
<meta property="og:site_name" content="EECE7398 Fall 2024">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="revealjs_14_gpu_compilers.qmd.html"><i class="bi bi-file-slides"></i>RevealJS</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">GPU Compilers</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="challenges-in-learning-about-gpus" class="level2">
<h2 class="anchored" data-anchor-id="challenges-in-learning-about-gpus">Challenges in Learning About GPUs</h2>
<ol type="1">
<li><strong>Architectural Variations</strong>
<ul>
<li>All the vendors keep changing the architecture. Different vendors build different hardware. Graphics programs run on all vendors’ hardware because vendors ship their own drivers and do finalization on the device.</li>
</ul></li>
<li><strong>Inconsistent Terminology</strong>
<ul>
<li>Vendors use different terms for the same features and reuse CPU terms somewhat differently. For instance, a “Cuda core” is not the same as a ‘CPU core’.</li>
</ul></li>
<li><strong>Legacy Terminology</strong>
<ul>
<li>Some terms come from the GPU’s history of graphics. For example, a shader is a program.</li>
</ul></li>
<li><strong>Software Abstractions</strong>
<ul>
<li>Big frameworks hide the details.</li>
</ul></li>
<li><strong>CUDA’s Market Dominance</strong>
<ul>
<li>Most explanations use CUDA terms since CUDA is the market leader. For instance, AMD uses ‘wave’ to mean more or less the same as a CUDA ‘warp’, but lots of AMD documentation uses ‘warps’.</li>
</ul></li>
<li><strong>CUDA: Language and Model</strong>
<ul>
<li>CUDA is both a programming language and a programming model, so you can have CUDA Fortran, CUDA Python, etc.</li>
</ul></li>
</ol>
</section>
<section id="hardware-styles-nvidia-model" class="level2">
<h2 class="anchored" data-anchor-id="hardware-styles-nvidia-model">hardware styles NVIDIA model</h2>
<ol type="1">
<li>compute and graphics parts have same programmable parts, compute leaves out non-programmable features</li>
<li>graphics customers pay a <strong><em>tax</em></strong> for the compute instructions</li>
<li>more transistors for compute instructions</li>
<li>one big die</li>
</ol>
</section>
<section id="hardware-styles-amd-model" class="level2">
<h2 class="anchored" data-anchor-id="hardware-styles-amd-model">hardware styles AMD model</h2>
<ol type="1">
<li>compute has extra instructions (no tax on graphics customers to support compute)</li>
<li>chiplet model (great engineering!)</li>
<li>R series is graphics, C series is compute</li>
</ol>
</section>
<section id="programming-model" class="level2">
<h2 class="anchored" data-anchor-id="programming-model">programming model</h2>
<p>both vendors use the CUDA programming model. AMD supports a variation of the CUDA language</p>
<p>machines have multiple SIMD processors, each SIMD can be running a different instruction but each <strong><em>lane</em></strong> of a SIMD runs the same instruction</p>
<p>a <strong><em>lane</em></strong> of a SIMD is called a <strong><em>thread</em></strong></p>
<hr>
<p>the programming model is SIMT (single instruction multiple threads)</p>
<p>User writes a scalar program, compiler maps that program to a lane of a SIMD, many instances of the program run at once, hardware combines copies of the scalar program into <strong><em>warps</em></strong>, hardware schedules warps into the SIMD engines</p>
<p>programs are called <strong><em>kernels</em></strong></p>
</section>
<section id="threading-model" class="level2">
<h2 class="anchored" data-anchor-id="threading-model">threading model</h2>
</section>
<section id="warps-waveswavefronts" class="level2">
<h2 class="anchored" data-anchor-id="warps-waveswavefronts"><strong><em>warps/ waves/wavefronts</em></strong></h2>
<ol type="1">
<li>threads are grouped together into <strong><em>warps</em></strong>.</li>
<li>Size is fixed by hardware (usually 32), programmers know this and often make data set sizes a multiple of 32.</li>
<li>since all threads in a warp are running the same instruction, there is no need for explicit synchronization</li>
<li>there are a few instructions that work across a warp, - which break the model and give the compiler problems</li>
</ol>
</section>
<section id="thread-blocks-groups-of-warps" class="level2">
<h2 class="anchored" data-anchor-id="thread-blocks-groups-of-warps"><strong><em>thread blocks</em></strong> groups of warps,</h2>
<ol type="1">
<li>threads within a block can access a fast scratchpad memory (called shared or LDS) - Violates the C memory model.<br>
</li>
<li>threads are identified by a 3d index inside a block</li>
<li>thread blocks need synchronization operations.<br>
</li>
<li>hardware schedules each block into execution units. Max block size is limited by the size of a execution unit.</li>
</ol>
</section>
<section id="grid-groups-of-blocks" class="level2">
<h2 class="anchored" data-anchor-id="grid-groups-of-blocks"><strong><em>grid</em></strong> groups of blocks,</h2>
<ol type="1">
<li>3d collection of blocks,</li>
<li>usually hardware limits mean that all the threads in a grid do not run at the same time</li>
<li>programmers need to make grids big enough to fill the hardware</li>
<li>software launches a grid and a program</li>
<li>threads within a grid but in different blocks do not have sync operations</li>
</ol>
</section>
<section id="heterogeneous-programming" class="level2">
<h2 class="anchored" data-anchor-id="heterogeneous-programming">Heterogeneous programming</h2>
<p>the cpu is called the <strong><em>host</em></strong></p>
<p>the gpu is called the <strong><em>device</em></strong></p>
<p>cpu launches grids and kernels to gpu</p>
<p>Computations launched on the device execute asynchronously with respect to the host, and it is the user’s responsibility to synchronize</p>
</section>
<section id="memory-spaces" class="level2">
<h2 class="anchored" data-anchor-id="memory-spaces">memory spaces</h2>
<ol type="1">
<li>cpu and gpu have different memory spaces (cpu can copy from one to the other). Some amount of combined memory (slower the not combined)</li>
<li>gpu has <strong><em>shared/lds</em></strong> memory which can be accessed by threads within a block, passing an address to a different block does not work</li>
<li>main gpu memory is called <strong><em>global</em></strong> accessible by all threads</li>
<li>gpu has per thread memory called <strong><em>local</em></strong> or <strong><em>scratch</em></strong> ot <strong><em>private</em></strong> memory - unlike C, passing an address in local memory to another thread does not work. (under some restrictions AMD implements part of the C memory model)</li>
<li>a few special gpu memory types: constant, texture, surface (left over from graphics)</li>
<li>gpu can treat registers as fast memory</li>
</ol>
</section>
<section id="hardware" class="level2">
<h2 class="anchored" data-anchor-id="hardware">Hardware</h2>
<p>NVIDIA</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/level0-nv.png" class="img-fluid figure-img"></p>
<figcaption>nv image level 0</figcaption>
</figure>
</div>
<p>Each box here is hardware, an int32/fp32/fp64 can perform one operation, so here we have 32 fp32 units which can do 32 float operations in parallel as well as 16 int32 and 16 fp64 units , there are also 8 units can do loads or stores and a final special function unit that can do transcendental operations like sin/cos</p>
<p>under some conditions two instructions (a float and an int) from the same warp can execute at the same time</p>
<p>I’m not going to talk much about the tensor cores</p>
<p>all these units execute the same instruction (SIMT) Simple instruction multiple thread (not the same as SIMD but related )</p>
</section>
<section id="one-instruction-does-vector-work" class="level2">
<h2 class="anchored" data-anchor-id="one-instruction-does-vector-work">one instruction does vector work</h2>
<p>add 32 float32 values (all coming from registers) and store the result in 32 other registers</p>
<p>Notice no branch prediction, no out of order execution</p>
<p>great at switching a warp holds the instruction, it knows which registers it owns (continuous set, so it just needs a start and length) switching to a different warp, means changing these two numbers and the pc (this is done by the dispatch unt )</p>
<p>When we do a load, we need to wait for the result. CPU might do some kind of out of order execution, a gpu switches to another warp</p>
<p>finally we need to pick the warp to switch to, this is done by the warp scheduler (half of the hardware scheduler)</p>
</section>
<section id="streaming-multiprocessors-sm" class="level2">
<h2 class="anchored" data-anchor-id="streaming-multiprocessors-sm">streaming multiprocessors (SM)</h2>
<p>nvidia packs 4 execution engines into a SM (streaming multi-processor) ands an L1 instruction cache, a special memory accelerator for tensors and 256kb l1 data cache/ shared memory block</p>
<p><img src="images/nv-1-sm.bmp" class="img-fluid"></p>
</section>
<section id="pack-sms-together" class="level2">
<h2 class="anchored" data-anchor-id="pack-sms-together">pack sm’s together</h2>
<p><img src="images/nv-sms.jpg" class="img-fluid"></p>
</section>
<section id="amd" class="level2">
<h2 class="anchored" data-anchor-id="amd">AMD</h2>
</section>
<section id="and" class="level2">
<h2 class="anchored" data-anchor-id="and">and</h2>
<p><img src="images/amd-compute-unit.svg" class="img-fluid"></p>
<p>AMD has a similar block with some important differences</p>
<ol type="1">
<li>At the bottom of a compute core there are 4 general purpose simd engines each of length 16 and one scalar engine</li>
</ol>
<p>Given 5 waves, this compute core can execute 4 vector instructions and one scalar instruction per clock Two instructions from the same wave never execute at the same time</p>
<p>The SIMD engines can execute different instructions</p>
<p>The simd sizes vary over different chips</p>
</section>
<section id="amd-cdna" class="level2">
<h2 class="anchored" data-anchor-id="amd-cdna">amd CDNA</h2>
<p><img src="images/amd-cu.png" class="img-fluid"></p>
</section>
<section id="packing-sms" class="level2">
<h2 class="anchored" data-anchor-id="packing-sms">packing sms</h2>
<p><img src="images/cdna2_gcd.png" class="img-fluid"></p>
</section>
<section id="simd-and-control-flow" class="level2">
<h2 class="anchored" data-anchor-id="simd-and-control-flow">simd and control flow</h2>
<p>to execute an if then else</p>
<ol type="1">
<li>compute the if condition</li>
<li>turn off the lanes where the condition is false</li>
<li>execute the if side</li>
<li>flip the lanes</li>
<li>execute the else side</li>
</ol>
<p>time is the sum of the times for then and the else</p>
</section>
<section id="number-of-warps-in-flight" class="level2">
<h2 class="anchored" data-anchor-id="number-of-warps-in-flight">number of warps in flight</h2>
<p>since an entire block has to fit on one compute unit/sm, the resources used in the block limit the number of warps on a sm,</p>
<p>if a warp needs 100 registers and there are 256 vector registers on the compute unit, then two warps can run at once, compiler controls number of registers</p>
</section>
<section id="latency" class="level2">
<h2 class="anchored" data-anchor-id="latency">latency</h2>
<p>gpu is a throughput machine- how many threads finish in a unit of time not how long a single thread takes to finish</p>
<p>unlike the cpu, gpu can have lots of loads in flight, time for these loads overlap so compiler tries to group loads together, but this needs extra registers</p>
<ol type="1">
<li>a warp issues a group of loads</li>
<li>warp issues a wait for loads to finish (hardware in cpu, software in gpu)</li>
<li>hardware switches to another warp (if there is on), good to have a lot of warps 1, if all warps waiting for memory, alu units are idle</li>
</ol>
</section>
<section id="differences" class="level1">
<h1>differences</h1>
<ol type="1">
<li>NVIDA committed to AI, and cut down on the non-tensor operations, AND did not</li>
<li>Generally you need more waves on an AMD processor</li>
<li>AMD added infinity connectors so that they could use chiplets</li>
<li>AMD has a scalar processor - The programming model does not - So its up to the compiler to use it</li>
<li>NVIDIA has 1 architecture for the compiler, AMD has two</li>
</ol>
<section id="compiler-model" class="level2">
<h2 class="anchored" data-anchor-id="compiler-model">compiler model</h2>
<ol type="1">
<li>like a regular compiler for a scalar machine</li>
<li>new problem: registers used in warp limits number of warps in flight, so ra is different</li>
<li>new problem: control flow is more critical</li>
<li>new problem: latency means grouping loads but not to much</li>
<li>new problem: arch keeps changing</li>
</ol>
</section>
<section id="thread-coarsening" class="level2">
<h2 class="anchored" data-anchor-id="thread-coarsening">thread coarsening</h2>
<p>Suppose we are computing a matrix multiply</p>
<p>we could say each thread writes one result so a 32 x 32 matrix would need 32 * 32 threads each thread reads one column and one row of the input,</p>
<p>we have a lot of reuse (redundant loads of data )</p>
<p>we could say each thread writes 4 results, so we need 1/4 of the threads each thread reads a raw and 4 columns</p>
</section>
<section id="technique" class="level2">
<h2 class="anchored" data-anchor-id="technique">technique</h2>
<ol type="1">
<li>merge multiple threads so each resulting thread writes multiple outputs</li>
<li>do the redundant work once and save in registers</li>
<li>use the registers for computing all the outputs</li>
</ol>
<p>But</p>
<ol type="1">
<li>needs extra registers</li>
<li>increased efficiency but reduced parallelism</li>
</ol>
<p>After thread coarsening, computation from merged threads can see each others results</p>
</section>
<section id="doing-this-by-hand" class="level2">
<h2 class="anchored" data-anchor-id="doing-this-by-hand">doing this by hand</h2>
<pre><code>for (atomid=0; atomid&lt;numatoms; atomid++) { 
  float dy = coory - atominfo[atomid].y; 
  float dysqpdzsq = (dy * dy) + atominfo[atomid].z; 
  float dx1 = coorx1 - atominfo[atomid].x; 
  float dx2 = coorx2 - atominfo[atomid].x; 
  float dx3 = coorx3 - atominfo[atomid].x; 
  float dx4 = coorx4 - atominfo[atomid].x; 
  energyvalx1 += atominfo[atomid].w * (1.0f / sqrtf(dx1*dx1 + dysqpdzsq));
  energyvalx2 += atominfo[atomid].w * (1.0f / sqrtf(dx2*dx2 + dysqpdzsq)); 
  energyvalx3 += atominfo[atomid].w * (1.0f / sqrtf(dx3*dx3 + dysqpdzsq)); 
  energyvalx4 += atominfo[atomid].w * (1.0f / sqrtf(dx4*dx4 + dysqpdzsq)); } …</code></pre>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/normrubin\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><a href="https://normrubin.github.io/">EECS 7398 website</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions"><ul><li><a href="https://github.com/normrubin/normrubin.github.io/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This page is built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>